{"version":3,"sources":["../node_modules/anim-event/anim-event.esm.js","../node_modules/pointer-event/pointer-event.esm.js","../node_modules/cssprefix/cssprefix.esm.js","../node_modules/m-class-list/m-class-list.esm.js","plainDraggable.ts"],"names":["AnimEvent","MSPF","KEEP_LOOP","tasks","requestAnim","window","requestAnimationFrame","mozRequestAnimationFrame","webkitRequestAnimationFrame","msRequestAnimationFrame","callback","setTimeout","cancelAnim","cancelAnimationFrame","mozCancelAnimationFrame","webkitCancelAnimationFrame","msCancelAnimationFrame","requestID","clearTimeout","lastFrameTime","Date","now","step","called","next","call","forEach","task","event","listener","indexOfTasks","index","some","i","add","push","remove","iRemove","splice","length","PointerEvent","_createClass","defineProperties","target","props","descriptor","enumerable","configurable","writable","Object","defineProperty","key","Constructor","protoProps","staticProps","prototype","_classCallCheck","instance","TypeError","MOUSE_EMU_INTERVAL","passiveSupported","addEventListener","get","error","addEventListenerWithOptions","type","options","capture","getTouchById","touches","id","identifier","hasXY","xy","clientX","clientY","dragstart","preventDefault","_this","startHandlers","lastHandlerId","curPointerClass","curTouchId","lastPointerXY","lastTouchTime","stopPropagation","option","value","startHandler","that","pointerClass","pointerXY","touchId","changedTouches","Error","cancel","handlerId","element","passive","removeEventListener","moveHandler","wrappedHandler","move","curMoveHandler","endHandler","end","curEndHandler","cancelHandler","curCancelHandler","CSSPrefix","ucf","text","substr","toUpperCase","PREFIXES","NAME_PREFIXES","reduce","prefixes","prefix","VALUE_PREFIXES","map","getDeclaration","declaration","document","createElement","style","normalizeName","rePrefixedName","RegExp","join","reUc","propName","replace","str","p1","test","toLowerCase","normalizeValue","rePrefixedValue","propValue","cssSupports","setProperty","getPropertyValue","propNames","propValues","getName","ucfName","prefixed","getValue","res","Array","isArray","mClassList","normalize","token","trim","applyList","list","setAttribute","_add","tokens","filter","indexOf","_remove","_toggle","force","_replace","newToken","ignoreNative","classList","getAttribute","split","ins","item","contains","slice","arguments","methodChain","toggle"],"mappings":"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","file":"plainDraggable.min.js","sourceRoot":"../src","sourcesContent":["/* ================================================\n        DON'T MANUALLY EDIT THIS FILE\n================================================ */\n\n/*\n * AnimEvent\n * https://github.com/anseki/anim-event\n *\n * Copyright (c) 2018 anseki\n * Licensed under the MIT license.\n */\n\nvar MSPF = 1000 / 60,\n    // ms/frame (FPS: 60)\nKEEP_LOOP = 500,\n\n\n/**\n * @typedef {Object} task\n * @property {Event} event\n * @property {function} listener\n */\n\n/** @type {task[]} */\ntasks = [];\n\nvar requestAnim = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || function (callback) {\n  return setTimeout(callback, MSPF);\n},\n    cancelAnim = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelAnimationFrame || function (requestID) {\n  return clearTimeout(requestID);\n};\n\nvar lastFrameTime = Date.now(),\n    requestID = void 0;\n\nfunction step() {\n  var called = void 0,\n      next = void 0;\n\n  if (requestID) {\n    cancelAnim.call(window, requestID);\n    requestID = null;\n  }\n\n  tasks.forEach(function (task) {\n    var event = void 0;\n    if (event = task.event) {\n      task.event = null; // Clear it before `task.listener()` because that might fire another event.\n      task.listener(event);\n      called = true;\n    }\n  });\n\n  if (called) {\n    lastFrameTime = Date.now();\n    next = true;\n  } else if (Date.now() - lastFrameTime < KEEP_LOOP) {\n    // Go on for a while\n    next = true;\n  }\n  if (next) {\n    requestID = requestAnim.call(window, step);\n  }\n}\n\nfunction indexOfTasks(listener) {\n  var index = -1;\n  tasks.some(function (task, i) {\n    if (task.listener === listener) {\n      index = i;\n      return true;\n    }\n    return false;\n  });\n  return index;\n}\n\nvar AnimEvent = {\n  /**\n   * @param {function} listener - An event listener.\n   * @returns {(function|null)} A wrapped event listener.\n   */\n  add: function add(listener) {\n    var task = void 0;\n    if (indexOfTasks(listener) === -1) {\n      tasks.push(task = { listener: listener });\n      return function (event) {\n        task.event = event;\n        if (!requestID) {\n          step();\n        }\n      };\n    }\n    return null;\n  },\n  remove: function remove(listener) {\n    var iRemove = void 0;\n    if ((iRemove = indexOfTasks(listener)) > -1) {\n      tasks.splice(iRemove, 1);\n      if (!tasks.length && requestID) {\n        cancelAnim.call(window, requestID);\n        requestID = null;\n      }\n    }\n  }\n};\n\nexport default AnimEvent;","/* ================================================\n        DON'T MANUALLY EDIT THIS FILE\n================================================ */\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/*\n * PointerEvent\n * https://github.com/anseki/pointer-event\n *\n * Copyright (c) 2018 anseki\n * Licensed under the MIT license.\n */\n\nimport AnimEvent from 'anim-event';\n\nvar MOUSE_EMU_INTERVAL = 400; // Avoid mouse events emulation\n\n\n// Support options for addEventListener\nvar passiveSupported = false;\ntry {\n  window.addEventListener('test', null, Object.defineProperty({}, 'passive', {\n    get: function get() {\n      passiveSupported = true;\n    }\n  }));\n} catch (error) {} /* ignore */\n\n/**\n * addEventListener with specific option.\n * @param {Element} target - An event-target element.\n * @param {string} type - The event type to listen for.\n * @param {function} listener - The EventListener.\n * @param {Object} options - An options object.\n * @returns {void}\n */\nfunction addEventListenerWithOptions(target, type, listener, options) {\n  // When `passive` is not supported, consider that the `useCapture` is supported instead of\n  // `options` (i.e. options other than the `passive` also are not supported).\n  target.addEventListener(type, listener, passiveSupported ? options : options.capture);\n}\n\n/**\n * Get Touch instance in list.\n * @param {Touch[]} touches - An Array or TouchList instance.\n * @param {number} id - Touch#identifier\n * @returns {(Touch|null)} - A found Touch instance.\n */\nfunction getTouchById(touches, id) {\n  if (touches != null && id != null) {\n    for (var i = 0; i < touches.length; i++) {\n      if (touches[i].identifier === id) {\n        return touches[i];\n      }\n    }\n  }\n  return null;\n}\n\n/**\n * @param {Object} xy - Something that might have clientX and clientY.\n * @returns {boolean} - `true` if it has valid clientX and clientY.\n */\nfunction hasXY(xy) {\n  return xy && typeof xy.clientX === 'number' && typeof xy.clientY === 'number';\n}\n\n// Gecko, Trident pick drag-event of some elements such as img, a, etc.\nfunction dragstart(event) {\n  event.preventDefault();\n}\n\nvar PointerEvent = function () {\n  /**\n   * Create a `PointerEvent` instance.\n   * @param {Object} [options] - Options\n   */\n  function PointerEvent(options) {\n    var _this = this;\n\n    _classCallCheck(this, PointerEvent);\n\n    this.startHandlers = {};\n    this.lastHandlerId = 0;\n    this.curPointerClass = null;\n    this.curTouchId = null;\n    this.lastPointerXY = { clientX: 0, clientY: 0 };\n    this.lastTouchTime = 0;\n\n    // Options\n    this.options = { // Default\n      preventDefault: true,\n      stopPropagation: true\n    };\n    if (options) {\n      ['preventDefault', 'stopPropagation'].forEach(function (option) {\n        if (typeof options[option] === 'boolean') {\n          _this.options[option] = options[option];\n        }\n      });\n    }\n  }\n\n  /**\n   * @param {function} startHandler - This is called with pointerXY when it starts. This returns boolean.\n   * @returns {number} handlerId which is used for adding/removing to element.\n   */\n\n\n  _createClass(PointerEvent, [{\n    key: 'regStartHandler',\n    value: function regStartHandler(startHandler) {\n      var that = this;\n      that.startHandlers[++that.lastHandlerId] = function (event) {\n        var pointerClass = event.type === 'mousedown' ? 'mouse' : 'touch',\n            now = Date.now();\n        var pointerXY = void 0,\n            touchId = void 0;\n\n        if (pointerClass === 'touch') {\n          that.lastTouchTime = now; // Avoid mouse events emulation\n          pointerXY = event.changedTouches[0];\n          touchId = event.changedTouches[0].identifier;\n        } else {\n          // Avoid mouse events emulation\n          if (now - that.lastTouchTime < MOUSE_EMU_INTERVAL) {\n            return;\n          }\n          pointerXY = event;\n        }\n        if (!hasXY(pointerXY)) {\n          throw new Error('No clientX/clientY');\n        }\n\n        // It is new one even if those are 'mouse' or ID is same, then cancel current one.\n        if (that.curPointerClass) {\n          that.cancel();\n        }\n\n        if (startHandler.call(that, pointerXY)) {\n          that.curPointerClass = pointerClass;\n          that.curTouchId = pointerClass === 'touch' ? touchId : null;\n          that.lastPointerXY.clientX = pointerXY.clientX;\n          that.lastPointerXY.clientY = pointerXY.clientY;\n          if (that.options.preventDefault) {\n            event.preventDefault();\n          }\n          if (that.options.stopPropagation) {\n            event.stopPropagation();\n          }\n        }\n      };\n      return that.lastHandlerId;\n    }\n\n    /**\n     * @param {number} handlerId - An ID which was returned by regStartHandler.\n     * @returns {void}\n     */\n\n  }, {\n    key: 'unregStartHandler',\n    value: function unregStartHandler(handlerId) {\n      delete this.startHandlers[handlerId];\n    }\n\n    /**\n     * @param {Element} element - A target element.\n     * @param {number} handlerId - An ID which was returned by regStartHandler.\n     * @returns {number} handlerId which was passed.\n     */\n\n  }, {\n    key: 'addStartHandler',\n    value: function addStartHandler(element, handlerId) {\n      if (!this.startHandlers[handlerId]) {\n        throw new Error('Invalid handlerId: ' + handlerId);\n      }\n      addEventListenerWithOptions(element, 'mousedown', this.startHandlers[handlerId], { capture: false, passive: false });\n      addEventListenerWithOptions(element, 'touchstart', this.startHandlers[handlerId], { capture: false, passive: false });\n      addEventListenerWithOptions(element, 'dragstart', dragstart, { capture: false, passive: false });\n      return handlerId;\n    }\n\n    /**\n     * @param {Element} element - A target element.\n     * @param {number} handlerId - An ID which was returned by regStartHandler.\n     * @returns {number} handlerId which was passed.\n     */\n\n  }, {\n    key: 'removeStartHandler',\n    value: function removeStartHandler(element, handlerId) {\n      if (!this.startHandlers[handlerId]) {\n        throw new Error('Invalid handlerId: ' + handlerId);\n      }\n      element.removeEventListener('mousedown', this.startHandlers[handlerId], false);\n      element.removeEventListener('touchstart', this.startHandlers[handlerId], false);\n      element.removeEventListener('dragstart', dragstart, false);\n      return handlerId;\n    }\n\n    /**\n     * @param {Element} element - A target element.\n     * @param {function} moveHandler - This is called with pointerXY when it moves.\n     * @returns {void}\n     */\n\n  }, {\n    key: 'addMoveHandler',\n    value: function addMoveHandler(element, moveHandler) {\n      var that = this;\n      var wrappedHandler = AnimEvent.add(function (event) {\n        var pointerClass = event.type === 'mousemove' ? 'mouse' : 'touch';\n\n        // Avoid mouse events emulation\n        if (pointerClass === 'touch') {\n          that.lastTouchTime = Date.now();\n        }\n\n        if (pointerClass === that.curPointerClass) {\n          var pointerXY = pointerClass === 'touch' ? getTouchById(event.changedTouches, that.curTouchId) : event;\n          if (hasXY(pointerXY)) {\n            if (pointerXY.clientX !== that.lastPointerXY.clientX || pointerXY.clientY !== that.lastPointerXY.clientY) {\n              that.move(pointerXY);\n            }\n            if (that.options.preventDefault) {\n              event.preventDefault();\n            }\n            if (that.options.stopPropagation) {\n              event.stopPropagation();\n            }\n          }\n        }\n      });\n      addEventListenerWithOptions(element, 'mousemove', wrappedHandler, { capture: false, passive: false });\n      addEventListenerWithOptions(element, 'touchmove', wrappedHandler, { capture: false, passive: false });\n      that.curMoveHandler = moveHandler;\n    }\n\n    /**\n     * @param {{clientX, clientY}} [pointerXY] - This might be MouseEvent, Touch of TouchEvent or Object.\n     * @returns {void}\n     */\n\n  }, {\n    key: 'move',\n    value: function move(pointerXY) {\n      if (hasXY(pointerXY)) {\n        this.lastPointerXY.clientX = pointerXY.clientX;\n        this.lastPointerXY.clientY = pointerXY.clientY;\n      }\n      if (this.curMoveHandler) {\n        this.curMoveHandler(this.lastPointerXY);\n      }\n    }\n\n    /**\n     * @param {Element} element - A target element.\n     * @param {function} endHandler - This is called with pointerXY when it ends.\n     * @returns {void}\n     */\n\n  }, {\n    key: 'addEndHandler',\n    value: function addEndHandler(element, endHandler) {\n      var that = this;\n      function wrappedHandler(event) {\n        var pointerClass = event.type === 'mouseup' ? 'mouse' : 'touch';\n\n        // Avoid mouse events emulation\n        if (pointerClass === 'touch') {\n          that.lastTouchTime = Date.now();\n        }\n\n        if (pointerClass === that.curPointerClass) {\n          var pointerXY = pointerClass === 'touch' ? getTouchById(event.changedTouches, that.curTouchId) || (\n          // It might have been removed from `touches` even if it is not in `changedTouches`.\n          getTouchById(event.touches, that.curTouchId) ? null : {}) : // `{}` means matching\n          event;\n          if (pointerXY) {\n            that.end(pointerXY);\n            if (that.options.preventDefault) {\n              event.preventDefault();\n            }\n            if (that.options.stopPropagation) {\n              event.stopPropagation();\n            }\n          }\n        }\n      }\n      addEventListenerWithOptions(element, 'mouseup', wrappedHandler, { capture: false, passive: false });\n      addEventListenerWithOptions(element, 'touchend', wrappedHandler, { capture: false, passive: false });\n      that.curEndHandler = endHandler;\n    }\n\n    /**\n     * @param {{clientX, clientY}} [pointerXY] - This might be MouseEvent, Touch of TouchEvent or Object.\n     * @returns {void}\n     */\n\n  }, {\n    key: 'end',\n    value: function end(pointerXY) {\n      if (hasXY(pointerXY)) {\n        this.lastPointerXY.clientX = pointerXY.clientX;\n        this.lastPointerXY.clientY = pointerXY.clientY;\n      }\n      if (this.curEndHandler) {\n        this.curEndHandler(this.lastPointerXY);\n      }\n      this.curPointerClass = this.curTouchId = null;\n    }\n\n    /**\n     * @param {Element} element - A target element.\n     * @param {function} cancelHandler - This is called when it cancels.\n     * @returns {void}\n     */\n\n  }, {\n    key: 'addCancelHandler',\n    value: function addCancelHandler(element, cancelHandler) {\n      var that = this;\n      function wrappedHandler(event) {\n        /*\n          Now, this is fired by touchcancel only, but it might be fired even if curPointerClass is mouse.\n        */\n        // const pointerClass = 'touch';\n\n        that.lastTouchTime = Date.now(); // Avoid mouse events emulation\n\n        if (that.curPointerClass != null) {\n          var pointerXY = getTouchById(event.changedTouches, that.curTouchId) || (\n          // It might have been removed from `touches` even if it is not in `changedTouches`.\n          getTouchById(event.touches, that.curTouchId) ? null : {}); // `{}` means matching\n          if (pointerXY) {\n            that.cancel();\n          }\n        }\n      }\n      addEventListenerWithOptions(element, 'touchcancel', wrappedHandler, { capture: false, passive: false });\n      that.curCancelHandler = cancelHandler;\n    }\n\n    /**\n     * @returns {void}\n     */\n\n  }, {\n    key: 'cancel',\n    value: function cancel() {\n      if (this.curCancelHandler) {\n        this.curCancelHandler();\n      }\n      this.curPointerClass = this.curTouchId = null;\n    }\n  }], [{\n    key: 'addEventListenerWithOptions',\n    get: function get() {\n      return addEventListenerWithOptions;\n    }\n  }]);\n\n  return PointerEvent;\n}();\n\nexport default PointerEvent;","/* ================================================\n        DON'T MANUALLY EDIT THIS FILE\n================================================ */\n\n/*\n * CSSPrefix\n * https://github.com/anseki/cssprefix\n *\n * Copyright (c) 2018 anseki\n * Licensed under the MIT license.\n */\n\nfunction ucf(text) {\n  return text.substr(0, 1).toUpperCase() + text.substr(1);\n}\n\nvar PREFIXES = ['webkit', 'moz', 'ms', 'o'],\n    NAME_PREFIXES = PREFIXES.reduce(function (prefixes, prefix) {\n  prefixes.push(prefix);\n  prefixes.push(ucf(prefix));\n  return prefixes;\n}, []),\n    VALUE_PREFIXES = PREFIXES.map(function (prefix) {\n  return '-' + prefix + '-';\n}),\n\n\n/**\n * Get sample CSSStyleDeclaration.\n * @returns {CSSStyleDeclaration}\n */\ngetDeclaration = function () {\n  var declaration = void 0;\n  return function () {\n    return declaration = declaration || document.createElement('div').style;\n  };\n}(),\n\n\n/**\n * Normalize name.\n * @param {} propName - A name that is normalized.\n * @returns {string} A normalized name.\n */\nnormalizeName = function () {\n  var rePrefixedName = new RegExp('^(?:' + PREFIXES.join('|') + ')(.)', 'i'),\n      reUc = /[A-Z]/;\n  return function (propName) {\n    return (propName = (propName + '').replace(/\\s/g, '').replace(/-([\\da-z])/gi, function (str, p1) {\n      return p1.toUpperCase();\n    }) // camelCase\n    // 'ms' and 'Ms' are found by rePrefixedName 'i' option\n    .replace(rePrefixedName, function (str, p1) {\n      return reUc.test(p1) ? p1.toLowerCase() : str;\n    }) // Remove prefix\n    ).toLowerCase() === 'float' ? 'cssFloat' : propName;\n  }; // For old CSSOM\n}(),\n\n\n/**\n * Normalize value.\n * @param {} propValue - A value that is normalized.\n * @returns {string} A normalized value.\n */\nnormalizeValue = function () {\n  var rePrefixedValue = new RegExp('^(?:' + VALUE_PREFIXES.join('|') + ')', 'i');\n  return function (propValue) {\n    return (propValue != null ? propValue + '' : '').replace(/\\s/g, '').replace(rePrefixedValue, '');\n  };\n}(),\n\n\n/**\n * Polyfill for `CSS.supports`.\n * @param {string} propName - A name.\n * @param {string} propValue - A value.\n *     Since `CSSStyleDeclaration.setProperty` might return unexpected result,\n *     the `propValue` should be checked before the `cssSupports` is called.\n * @returns {boolean} `true` if given pair is accepted.\n */\ncssSupports = function () {\n  return (\n    // return window.CSS && window.CSS.supports || ((propName, propValue) => {\n    // `CSS.supports` doesn't find prefixed property.\n    function (propName, propValue) {\n      var declaration = getDeclaration();\n      // In some browsers, `declaration[prop] = value` updates any property.\n      propName = propName.replace(/[A-Z]/g, function (str) {\n        return '-' + str.toLowerCase();\n      }); // kebab-case\n      declaration.setProperty(propName, propValue);\n      return declaration[propName] != null && // Because getPropertyValue returns '' if it is unsupported\n      declaration.getPropertyValue(propName) === propValue;\n    }\n  );\n}(),\n\n\n// Cache\npropNames = {},\n    propValues = {};\n\nfunction getName(propName) {\n  propName = normalizeName(propName);\n  if (propName && propNames[propName] == null) {\n    var declaration = getDeclaration();\n\n    if (declaration[propName] != null) {\n      // Original\n      propNames[propName] = propName;\n    } else {\n      // Try with prefixes\n      var ucfName = ucf(propName);\n      if (!NAME_PREFIXES.some(function (prefix) {\n        var prefixed = prefix + ucfName;\n        if (declaration[prefixed] != null) {\n          propNames[propName] = prefixed;\n          return true;\n        }\n        return false;\n      })) {\n        propNames[propName] = false;\n      }\n    }\n  }\n  return propNames[propName] || void 0;\n}\n\nfunction getValue(propName, propValue) {\n  var res = void 0;\n\n  if (!(propName = getName(propName))) {\n    return res;\n  } // Invalid property\n\n  propValues[propName] = propValues[propName] || {};\n  (Array.isArray(propValue) ? propValue : [propValue]).some(function (propValue) {\n    propValue = normalizeValue(propValue);\n\n    if (propValues[propName][propValue] != null) {\n      // Cache\n      if (propValues[propName][propValue] !== false) {\n        res = propValues[propName][propValue];\n        return true;\n      }\n      return false; // Continue to next value\n    }\n\n    if (cssSupports(propName, propValue)) {\n      // Original\n      res = propValues[propName][propValue] = propValue;\n      return true;\n    }\n\n    if (VALUE_PREFIXES.some(function (prefix) {\n      // Try with prefixes\n      var prefixed = prefix + propValue;\n      if (cssSupports(propName, prefixed)) {\n        res = propValues[propName][propValue] = prefixed;\n        return true;\n      }\n      return false;\n    })) {\n      return true;\n    }\n\n    propValues[propName][propValue] = false;\n    return false; // Continue to next value\n  });\n\n  return typeof res === 'string' ? res : void 0; // It might be empty string.\n}\n\nvar CSSPrefix = {\n  getName: getName,\n  getValue: getValue\n};\n\nexport default CSSPrefix;","/* ================================================\n        DON'T MANUALLY EDIT THIS FILE\n================================================ */\n\n/*\n * mClassList\n * https://github.com/anseki/m-class-list\n *\n * Copyright (c) 2018 anseki\n * Licensed under the MIT license.\n */\n\nfunction normalize(token) {\n  return (token + '').trim();\n} // Not `||`\nfunction applyList(list, element) {\n  element.setAttribute('class', list.join(' '));\n}\n\nfunction _add(list, element, tokens) {\n  if (tokens.filter(function (token) {\n    if (!(token = normalize(token)) || list.indexOf(token) !== -1) {\n      return false;\n    }\n    list.push(token);\n    return true;\n  }).length) {\n    applyList(list, element);\n  }\n}\n\nfunction _remove(list, element, tokens) {\n  if (tokens.filter(function (token) {\n    var i = void 0;\n    if (!(token = normalize(token)) || (i = list.indexOf(token)) === -1) {\n      return false;\n    }\n    list.splice(i, 1);\n    return true;\n  }).length) {\n    applyList(list, element);\n  }\n}\n\nfunction _toggle(list, element, token, force) {\n  var i = list.indexOf(token = normalize(token));\n  if (i !== -1) {\n    if (force) {\n      return true;\n    }\n    list.splice(i, 1);\n    applyList(list, element);\n    return false;\n  }\n  if (force === false) {\n    return false;\n  }\n  list.push(token);\n  applyList(list, element);\n  return true;\n}\n\nfunction _replace(list, element, token, newToken) {\n  var i = void 0;\n  if (!(token = normalize(token)) || !(newToken = normalize(newToken)) || token === newToken || (i = list.indexOf(token)) === -1) {\n    return;\n  }\n  list.splice(i, 1);\n  if (list.indexOf(newToken) === -1) {\n    list.push(newToken);\n  }\n  applyList(list, element);\n}\n\nfunction mClassList(element) {\n  return !mClassList.ignoreNative && element.classList || function () {\n    var list = (element.getAttribute('class') || '').trim().split(/\\s+/).filter(function (token) {\n      return !!token;\n    }),\n        ins = {\n      length: list.length,\n      item: function item(i) {\n        return list[i];\n      },\n      contains: function contains(token) {\n        return list.indexOf(normalize(token)) !== -1;\n      },\n      add: function add() {\n        _add(list, element, Array.prototype.slice.call(arguments));\n        return mClassList.methodChain ? ins : void 0;\n      },\n      remove: function remove() {\n        _remove(list, element, Array.prototype.slice.call(arguments));\n        return mClassList.methodChain ? ins : void 0;\n      },\n\n      toggle: function toggle(token, force) {\n        return _toggle(list, element, token, force);\n      },\n      replace: function replace(token, newToken) {\n        _replace(list, element, token, newToken);\n        return mClassList.methodChain ? ins : void 0;\n      }\n    };\n    return ins;\n  }();\n}\n\nmClassList.methodChain = true;\n\nexport default mClassList;","/*\n * PlainDraggable\n * https://anseki.github.io/plain-draggable/\n *\n * Copyright (c) 2018 anseki\n * Licensed under the MIT license.\n */\n\nimport PointerEvent from 'pointer-event';\nimport CSSPrefix from 'cssprefix';\nimport AnimEvent from 'anim-event';\nimport mClassList from 'm-class-list';\nmClassList.ignoreNative = true;\n\nconst ZINDEX = 9000,\n  // [SNAP]\n  SNAP_GRAVITY = 20,\n  SNAP_CORNER = 'tl',\n  SNAP_SIDE = 'both',\n  SNAP_EDGE = 'both',\n  SNAP_BASE = 'containment',\n  SNAP_ALL_CORNERS = ['tl', 'tr', 'bl', 'br'],\n  SNAP_ALL_SIDES = ['start', 'end'],\n  SNAP_ALL_EDGES = ['inside', 'outside'],\n  // [/SNAP]\n\n  // [AUTO-SCROLL]\n  AUTOSCROLL_SPEED = [40, 200, 1000],\n  AUTOSCROLL_SENSITIVITY = [100, 40, 0],\n  // [/AUTO-SCROLL]\n\n  IS_EDGE =\n    '-ms-scroll-limit' in document.documentElement.style &&\n    '-ms-ime-align' in document.documentElement.style &&\n    !window.navigator.msPointerEnabled,\n  IS_TRIDENT = !IS_EDGE && !!(document as any).uniqueID, // Future Edge might support `document.uniqueID`.\n  IS_GECKO = 'MozAppearance' in document.documentElement.style,\n  IS_BLINK =\n    !IS_EDGE &&\n    !IS_GECKO && // Edge has `window.chrome`, and future Gecko might have that.\n    !!(window as any).chrome &&\n    !!(window as any).CSS,\n  IS_WEBKIT =\n    !IS_EDGE &&\n    !IS_TRIDENT &&\n    !IS_GECKO &&\n    !IS_BLINK && // Some engines support `webkit-*` properties.\n    !(window as any).chrome &&\n    'WebkitAppearance' in document.documentElement.style,\n  isObject = (() => {\n    const toString = {}.toString,\n      fnToString = {}.hasOwnProperty.toString,\n      objFnString = fnToString.call(Object);\n    return obj => {\n      let proto, constr;\n      return (\n        obj &&\n        toString.call(obj) === '[object Object]' &&\n        (!(proto = Object.getPrototypeOf(obj)) ||\n          ((constr =\n            proto.hasOwnProperty('constructor') && proto.constructor) &&\n            typeof constr === 'function' &&\n            fnToString.call(constr) === objFnString))\n      );\n    };\n  })(),\n  isFinite =\n    Number.isFinite ||\n    (value => typeof value === 'number' && (window as any).isFinite(value)),\n  /** @type {Object.<_id: number, props>} */\n  insProps = {},\n  pointerOffset: any = {},\n  pointerEvent = new PointerEvent();\n\nlet insId = 0,\n  activeProps,\n  hasMoved,\n  body,\n  // CSS property/value\n  cssValueDraggableCursor,\n  cssValueDraggingCursor,\n  cssOrgValueBodyCursor,\n  cssPropTransitionProperty,\n  cssPropTransform,\n  cssPropUserSelect,\n  cssOrgValueBodyUserSelect,\n  // Try to set `cursor` property.\n  cssWantedValueDraggableCursor: any = IS_WEBKIT\n    ? ['all-scroll', 'move']\n    : ['grab', 'all-scroll', 'move'],\n  cssWantedValueDraggingCursor: any = IS_WEBKIT ? 'move' : ['grabbing', 'move'],\n  // class\n  draggableClass = 'plain-draggable',\n  draggingClass = 'plain-draggable-dragging',\n  movingClass = 'plain-draggable-moving';\n\n// [AUTO-SCROLL]\n// Scroll Animation Controller\nconst scrollFrame: any = {},\n  MSPF = 1000 / 60, // ms/frame (FPS: 60)\n  requestAnim =\n    window.requestAnimationFrame ||\n    (window as any).mozRequestAnimationFrame ||\n    window.webkitRequestAnimationFrame ||\n    (window as any).msRequestAnimationFrame ||\n    (callback => setTimeout(callback, MSPF)),\n  cancelAnim =\n    window.cancelAnimationFrame ||\n    (window as any).mozCancelAnimationFrame ||\n    window.webkitCancelAnimationFrame ||\n    (window as any).msCancelAnimationFrame ||\n    (requestID => clearTimeout(requestID));\n{\n  /**\n   * @typedef {Object} MoveArgs\n   * @property {number} dir - [-1 | 1] minus or plus to position value.\n   * @property {number} speed - px/ms\n   * @property {number} min - Minimum position value.\n   * @property {number} max - Maximum position value.\n   * @property {number} [lastFrameTime] - Time of last frame.\n   * @property {number} [lastValue] - Strict value of last frame.\n   */\n\n  let curXyMoveArgs: any = {},\n    curElement,\n    curScrollXY,\n    requestID;\n\n  function frameUpdate() {\n    const now = Date.now();\n    ['x', 'y'].forEach(xy => {\n      const moveArgs = curXyMoveArgs[xy];\n      if (moveArgs) {\n        const timeLen = now - moveArgs.lastFrameTime,\n          absValue = curScrollXY(curElement, xy),\n          curValue =\n            moveArgs.lastValue != null &&\n            Math.abs(moveArgs.lastValue - absValue) < 10 // It was not moved manually\n              ? moveArgs.lastValue\n              : absValue;\n        if (\n          moveArgs.dir === -1\n            ? curValue > moveArgs.min\n            : curValue < moveArgs.max\n        ) {\n          let newValue = curValue + moveArgs.speed * timeLen * moveArgs.dir;\n          if (newValue < moveArgs.min) {\n            newValue = moveArgs.min;\n          } else if (newValue > moveArgs.max) {\n            newValue = moveArgs.max;\n          }\n          curScrollXY(curElement, xy, newValue);\n          moveArgs.lastValue = newValue;\n        }\n        moveArgs.lastFrameTime = now;\n      }\n    });\n  }\n\n  function frame() {\n    cancelAnim.call(window, requestID);\n    frameUpdate();\n    requestID = requestAnim.call(window, frame);\n  }\n\n  /**\n   * @param {Element} element - A target element.\n   * @param {{x: ?MoveArgs, y: ?MoveArgs}} xyMoveArgs - MoveArgs for x and y\n   * @param {function} scrollXY - (element: Element, xy: string, value: number) => number\n   * @returns {void}\n   */\n  scrollFrame.move = (element, xyMoveArgs, scrollXY) => {\n    cancelAnim.call(window, requestID);\n    frameUpdate(); // Update current data now because it might be not continuation.\n\n    // Re-use lastValue\n    if (curElement === element) {\n      if (xyMoveArgs.x && curXyMoveArgs.x) {\n        xyMoveArgs.x.lastValue = curXyMoveArgs.x.lastValue;\n      }\n      if (xyMoveArgs.y && curXyMoveArgs.y) {\n        xyMoveArgs.y.lastValue = curXyMoveArgs.y.lastValue;\n      }\n    }\n\n    curElement = element;\n    curXyMoveArgs = xyMoveArgs;\n    curScrollXY = scrollXY;\n\n    const now = Date.now();\n    ['x', 'y'].forEach(xy => {\n      const moveArgs = curXyMoveArgs[xy];\n      if (moveArgs) {\n        moveArgs.lastFrameTime = now;\n      }\n    });\n\n    requestID = requestAnim.call(window, frame);\n  };\n\n  scrollFrame.stop = () => {\n    cancelAnim.call(window, requestID);\n    frameUpdate();\n    curXyMoveArgs = {};\n    curElement = null; // Remove reference\n  };\n}\n\nfunction scrollXYWindow(element, xy, value = null) {\n  if (value != null) {\n    if (xy === 'x') {\n      element.scrollTo(value, element.pageYOffset);\n    } else {\n      element.scrollTo(element.pageXOffset, value);\n    }\n  }\n  return xy === 'x' ? element.pageXOffset : element.pageYOffset;\n}\n\nfunction scrollXYElement(element, xy, value = null) {\n  const prop = xy === 'x' ? 'scrollLeft' : 'scrollTop';\n  if (value != null) {\n    element[prop] = value;\n  }\n  return element[prop];\n}\n\n/**\n * @typedef {Object} Scrollable\n * @property {number} clientWidth - width of scrollable area.\n * @property {number} clientHeight - height of scrollable area.\n * @property {number} scrollWidth - width of inner content.\n * @property {number} scrollHeight - height of inner content.\n * @property {number} clientX - X of scrollable area, document coordinate.\n * @property {number} clientY - T of scrollable area, document coordinate.\n */\n\n/**\n * @param {Element} element - A target element.\n * @param {boolean} [isWindow] - `true` if element is window.\n * @param {boolean} [dontScroll] - `true` makes it skip scroll that gets scrollWidth/Height.\n * @returns {Scrollable} Information for scroll.\n */\nfunction getScrollable(element, isWindow, dontScroll) {\n  const scrollable: any = {};\n  let cmpStyleHtml, cmpStyleBody, cmpStyleElement;\n\n  // clientWidth/Height\n  (function(target) {\n    scrollable.clientWidth = target.clientWidth;\n    scrollable.clientHeight = target.clientHeight;\n  })(isWindow ? document.documentElement : element);\n\n  // scrollWidth/Height\n  /*\n    Gecko bug, bottom-padding of element is reduced.\n    Blink for Android bug, borders of <html> is rendered but those are not added to scrollW/H.\n    Then, move it to max scroll position (sufficiently larger values) forcibly, and get scroll position.\n  */\n  let maxScrollLeft = 0,\n    maxScrollTop = 0;\n  if (!dontScroll) {\n    let curScrollLeft, curScrollTop;\n    if (isWindow) {\n      curScrollLeft = scrollXYWindow(element, 'x');\n      curScrollTop = scrollXYWindow(element, 'y');\n      cmpStyleHtml = getComputedStyle(document.documentElement, '');\n      cmpStyleBody = getComputedStyle(document.body, '');\n      maxScrollLeft = scrollXYWindow(\n        element,\n        'x',\n        document.documentElement.scrollWidth +\n        scrollable.clientWidth + // Blink for Android bug, scroll* returns size of smaller body\n          [\n            'marginLeft',\n            'marginRight',\n            'borderLeftWidth',\n            'borderRightWidth',\n            'paddingLeft',\n            'paddingRight',\n          ].reduce(\n            (len, prop) =>\n              len +\n              (parseFloat(cmpStyleHtml[prop]) || 0) +\n              (parseFloat(cmpStyleBody[prop]) || 0),\n            0,\n          ),\n      );\n      maxScrollTop = scrollXYWindow(\n        element,\n        'y',\n        document.documentElement.scrollHeight +\n          scrollable.clientHeight +\n          [\n            'marginTop',\n            'marginBottom',\n            'borderTopWidth',\n            'borderBottomWidth',\n            'paddingTop',\n            'paddingBottom',\n          ].reduce(\n            (len, prop) =>\n              len +\n              (parseFloat(cmpStyleHtml[prop]) || 0) +\n              (parseFloat(cmpStyleBody[prop]) || 0),\n            0,\n          ),\n      );\n\n      scrollXYWindow(element, 'x', curScrollLeft);\n      scrollXYWindow(element, 'y', curScrollTop);\n    } else {\n      curScrollLeft = scrollXYElement(element, 'x');\n      curScrollTop = scrollXYElement(element, 'y');\n      cmpStyleElement = getComputedStyle(element, '');\n      maxScrollLeft = scrollXYElement(\n        element,\n        'x',\n        element.scrollWidth +\n        scrollable.clientWidth + // Blink for Android bug, scroll* returns size of smaller body\n          [\n            'marginLeft',\n            'marginRight',\n            'borderLeftWidth',\n            'borderRightWidth',\n            'paddingLeft',\n            'paddingRight',\n          ].reduce(\n            (len, prop) => len + (parseFloat(cmpStyleElement[prop]) || 0),\n            0,\n          ),\n      );\n      maxScrollTop = scrollXYElement(\n        element,\n        'y',\n        element.scrollHeight +\n          scrollable.clientHeight +\n          [\n            'marginTop',\n            'marginBottom',\n            'borderTopWidth',\n            'borderBottomWidth',\n            'paddingTop',\n            'paddingBottom',\n          ].reduce(\n            (len, prop) => len + (parseFloat(cmpStyleElement[prop]) || 0),\n            0,\n          ),\n      );\n\n      scrollXYElement(element, 'x', curScrollLeft);\n      scrollXYElement(element, 'y', curScrollTop);\n    }\n  }\n  scrollable.scrollWidth = scrollable.clientWidth + maxScrollLeft;\n  scrollable.scrollHeight = scrollable.clientHeight + maxScrollTop;\n\n  // clientX/Y\n  let rect;\n  if (isWindow) {\n    scrollable.clientX = scrollable.clientY = 0;\n  } else {\n    // padding-box\n    rect = element.getBoundingClientRect();\n    if (!cmpStyleElement) {\n      cmpStyleElement = getComputedStyle(element, '');\n    }\n    scrollable.clientX =\n      rect.left + (parseFloat(cmpStyleElement.borderLeftWidth) || 0);\n    scrollable.clientY =\n      rect.top + (parseFloat(cmpStyleElement.borderTopWidth) || 0);\n  }\n\n  return scrollable;\n}\n// [/AUTO-SCROLL]\n\nfunction copyTree(obj) {\n  return !obj\n    ? obj\n    : isObject(obj)\n    ? Object.keys(obj).reduce((copyObj, key) => {\n        copyObj[key] = copyTree(obj[key]);\n        return copyObj;\n      }, {})\n    : Array.isArray(obj)\n    ? obj.map(copyTree)\n    : obj;\n}\n\nfunction hasChanged(a, b) {\n  let typeA, keysA;\n  return (\n    typeof a !== typeof b ||\n    (typeA = isObject(a) ? 'obj' : Array.isArray(a) ? 'array' : '') !==\n      (isObject(b) ? 'obj' : Array.isArray(b) ? 'array' : '') ||\n    (typeA === 'obj'\n      ? hasChanged((keysA = Object.keys(a).sort()), Object.keys(b).sort()) ||\n        keysA.some(prop => hasChanged(a[prop], b[prop]))\n      : typeA === 'array'\n      ? a.length !== b.length || a.some((aVal, i) => hasChanged(aVal, b[i]))\n      : a !== b)\n  );\n}\n\n/**\n * @param {Element} element - A target element.\n * @returns {boolean} `true` if connected element.\n */\nfunction isElement(element) {\n  return !!(\n    element &&\n    element.nodeType === Node.ELEMENT_NODE &&\n    // element instanceof HTMLElement &&\n    typeof element.getBoundingClientRect === 'function' &&\n    !(\n      element.compareDocumentPosition(document) &\n      Node.DOCUMENT_POSITION_DISCONNECTED\n    )\n  );\n}\n\n/**\n * An object that simulates `DOMRect` to indicate a bounding-box.\n * @typedef {Object} BBox\n * @property {(number|null)} left - document coordinate\n * @property {(number|null)} top - document coordinate\n * @property {(number|null)} right - document coordinate\n * @property {(number|null)} bottom - document coordinate\n * @property {(number|null)} x - Substitutes for left\n * @property {(number|null)} y - Substitutes for top\n * @property {(number|null)} width\n * @property {(number|null)} height\n */\n\n/**\n * @param {Object} bBox - A target object.\n * @returns {(BBox|null)} A normalized `BBox`, or null if `bBox` is invalid.\n */\nfunction validBBox(bBox) {\n  if (!isObject(bBox)) {\n    return null;\n  }\n  let value;\n  if (isFinite((value = bBox.left)) || isFinite((value = bBox.x))) {\n    bBox.left = bBox.x = value;\n  } else {\n    return null;\n  }\n  if (isFinite((value = bBox.top)) || isFinite((value = bBox.y))) {\n    bBox.top = bBox.y = value;\n  } else {\n    return null;\n  }\n\n  if (isFinite(bBox.width) && bBox.width >= 0) {\n    bBox.right = bBox.left + bBox.width;\n  } else if (isFinite(bBox.right) && bBox.right >= bBox.left) {\n    bBox.width = bBox.right - bBox.left;\n  } else {\n    return null;\n  }\n  if (isFinite(bBox.height) && bBox.height >= 0) {\n    bBox.bottom = bBox.top + bBox.height;\n  } else if (isFinite(bBox.bottom) && bBox.bottom >= bBox.top) {\n    bBox.height = bBox.bottom - bBox.top;\n  } else {\n    return null;\n  }\n  return bBox;\n}\n\n/**\n * A value that is Pixels or Ratio\n * @typedef {{value: number, isRatio: boolean}} PPValue\n */\n\nfunction validPPValue(value) {\n  // Get PPValue from string (all `/s` were already removed)\n  function string2PPValue(inString) {\n    const matches = /^(.+?)(%)?$/.exec(inString);\n    let value, isRatio;\n    return matches && isFinite((value = parseFloat(matches[1])))\n      ? {\n          value: (isRatio = !!(matches[2] && value)) ? value / 100 : value,\n          isRatio,\n        }\n      : null; // 0% -> 0\n  }\n\n  return isFinite(value)\n    ? { value, isRatio: false }\n    : typeof value === 'string'\n    ? string2PPValue(value.replace(/\\s/g, ''))\n    : null;\n}\n\nfunction ppValue2OptionValue(ppValue) {\n  return ppValue.isRatio ? `${ppValue.value * 100}%` : ppValue.value;\n}\n\nfunction resolvePPValue(ppValue, baseOrigin, baseSize) {\n  return typeof ppValue === 'number'\n    ? ppValue\n    : baseOrigin + ppValue.value * (ppValue.isRatio ? baseSize : 1);\n}\n\n/**\n * An object that simulates BBox but properties are PPValue.\n * @typedef {Object} PPBBox\n */\n\n/**\n * @param {Object} bBox - A target object.\n * @returns {(PPBBox|null)} A normalized `PPBBox`, or null if `bBox` is invalid.\n */\nfunction validPPBBox(bBox) {\n  if (!isObject(bBox)) {\n    return null;\n  }\n  let ppValue;\n  if ((ppValue = validPPValue(bBox.left)) || (ppValue = validPPValue(bBox.x))) {\n    bBox.left = bBox.x = ppValue;\n  } else {\n    return null;\n  }\n  if ((ppValue = validPPValue(bBox.top)) || (ppValue = validPPValue(bBox.y))) {\n    bBox.top = bBox.y = ppValue;\n  } else {\n    return null;\n  }\n\n  if ((ppValue = validPPValue(bBox.width)) && ppValue.value >= 0) {\n    bBox.width = ppValue;\n    delete bBox.right;\n  } else if ((ppValue = validPPValue(bBox.right))) {\n    bBox.right = ppValue;\n    delete bBox.width;\n  } else {\n    return null;\n  }\n  if ((ppValue = validPPValue(bBox.height)) && ppValue.value >= 0) {\n    bBox.height = ppValue;\n    delete bBox.bottom;\n  } else if ((ppValue = validPPValue(bBox.bottom))) {\n    bBox.bottom = ppValue;\n    delete bBox.height;\n  } else {\n    return null;\n  }\n  return bBox;\n}\n\nfunction ppBBox2OptionObject(ppBBox) {\n  return Object.keys(ppBBox).reduce((obj, prop) => {\n    obj[prop] = ppValue2OptionValue(ppBBox[prop]);\n    return obj;\n  }, {});\n}\n\n// PPBBox -> BBox\nfunction resolvePPBBox(ppBBox, baseBBox) {\n  const prop2Axis = {\n      left: 'x',\n      right: 'x',\n      x: 'x',\n      width: 'x',\n      top: 'y',\n      bottom: 'y',\n      y: 'y',\n      height: 'y',\n    },\n    baseOriginXY = { x: baseBBox.left, y: baseBBox.top },\n    baseSizeXY = { x: baseBBox.width, y: baseBBox.height };\n  return validBBox(\n    Object.keys(ppBBox).reduce((bBox, prop) => {\n      bBox[prop] = resolvePPValue(\n        ppBBox[prop],\n        prop === 'width' || prop === 'height'\n          ? 0\n          : baseOriginXY[prop2Axis[prop]],\n        baseSizeXY[prop2Axis[prop]],\n      );\n      return bBox;\n    }, {}),\n  );\n}\n\n/**\n * @param {Element} element - A target element.\n * @param {?boolean} getPaddingBox - Get padding-box instead of border-box as bounding-box.\n * @returns {BBox} A bounding-box of `element`.\n */\nfunction getBBox(element, getPaddingBox = null) {\n  const rect = element.getBoundingClientRect(),\n    bBox = {\n      left: rect.left,\n      top: rect.top,\n      width: rect.width,\n      height: rect.height,\n    };\n  bBox.left += window.pageXOffset;\n  bBox.top += window.pageYOffset;\n  if (getPaddingBox) {\n    const style = window.getComputedStyle(element, ''),\n      borderTop = parseFloat(style.borderTopWidth) || 0,\n      borderRight = parseFloat(style.borderRightWidth) || 0,\n      borderBottom = parseFloat(style.borderBottomWidth) || 0,\n      borderLeft = parseFloat(style.borderLeftWidth) || 0;\n    bBox.left += borderLeft;\n    bBox.top += borderTop;\n    bBox.width -= borderLeft + borderRight;\n    bBox.height -= borderTop + borderBottom;\n  }\n  return validBBox(bBox);\n}\n\n/**\n * Optimize an element for animation.\n * @param {Element} element - A target element.\n * @param {?boolean} gpuTrigger - Initialize for SVGElement if `true`.\n * @returns {Element} A target element.\n */\nfunction initAnim(element, gpuTrigger) {\n  const style = element.style;\n  style.webkitTapHighlightColor = 'transparent';\n\n  // Only when it has no shadow\n  const cssPropBoxShadow = CSSPrefix.getName('boxShadow'),\n    boxShadow = window.getComputedStyle(element, '')[cssPropBoxShadow];\n  if (!boxShadow || boxShadow === 'none') {\n    style[cssPropBoxShadow] = '0 0 1px transparent';\n  }\n\n  if (gpuTrigger && cssPropTransform) {\n    style[cssPropTransform] = 'translateZ(0)';\n  }\n  return element;\n}\n\nfunction setDraggableCursor(element, orgCursor) {\n  if (cssValueDraggableCursor == null) {\n    if (cssWantedValueDraggableCursor !== false) {\n      cssValueDraggableCursor = CSSPrefix.getValue(\n        'cursor',\n        cssWantedValueDraggableCursor,\n      );\n    }\n    // The wanted value was denied, or changing is not wanted.\n    if (cssValueDraggableCursor == null) {\n      cssValueDraggableCursor = false;\n    }\n  }\n  // Update it to change a state even if cssValueDraggableCursor is false.\n  element.style.cursor =\n    cssValueDraggableCursor === false ? orgCursor : cssValueDraggableCursor;\n}\n\nfunction setDraggingCursor(element) {\n  if (cssValueDraggingCursor == null) {\n    if (cssWantedValueDraggingCursor !== false) {\n      cssValueDraggingCursor = CSSPrefix.getValue(\n        'cursor',\n        cssWantedValueDraggingCursor,\n      );\n    }\n    // The wanted value was denied, or changing is not wanted.\n    if (cssValueDraggingCursor == null) {\n      cssValueDraggingCursor = false;\n    }\n  }\n  if (cssValueDraggingCursor !== false) {\n    element.style.cursor = cssValueDraggingCursor;\n  }\n}\n\n// [SVG]\n/**\n * Get SVG coordinates from viewport coordinates.\n * @param {props} props - `props` of instance.\n * @param {number} clientX - viewport X.\n * @param {number} clientY - viewport Y.\n * @returns {SVGPoint} SVG coordinates.\n */\nfunction viewPoint2SvgPoint(props, clientX, clientY) {\n  const svgPoint = props.svgPoint;\n  svgPoint.x = clientX;\n  svgPoint.y = clientY;\n  return svgPoint.matrixTransform(props.svgCtmElement.getScreenCTM().inverse());\n}\n// [/SVG]\n\n/**\n * Move by `translate`.\n * @param {props} props - `props` of instance.\n * @param {{left: number, top: number}} position - New position.\n * @returns {boolean} `true` if it was moved.\n */\nfunction moveTranslate(props, position) {\n  const elementBBox = props.elementBBox;\n  if (position.left !== elementBBox.left || position.top !== elementBBox.top) {\n    const offset = props.htmlOffset;\n    props.elementStyle[cssPropTransform] = `translate(${position.left +\n      offset.left}px, ${position.top + offset.top}px)`;\n    return true;\n  }\n  return false;\n}\n\n// [LEFTTOP]\n/**\n * Move by `left` and `top`.\n * @param {props} props - `props` of instance.\n * @param {{left: number, top: number}} position - New position.\n * @returns {boolean} `true` if it was moved.\n */\nfunction moveLeftTop(props, position) {\n  const elementBBox = props.elementBBox,\n    elementStyle = props.elementStyle,\n    offset = props.htmlOffset;\n  let moved = false;\n  if (position.left !== elementBBox.left) {\n    elementStyle.left = position.left + offset.left + 'px';\n    moved = true;\n  }\n  if (position.top !== elementBBox.top) {\n    elementStyle.top = position.top + offset.top + 'px';\n    moved = true;\n  }\n  return moved;\n}\n// [/LEFTTOP]\n\n// [SVG]\n/**\n * Move SVGElement.\n * @param {props} props - `props` of instance.\n * @param {{left: number, top: number}} position - New position.\n * @returns {boolean} `true` if it was moved.\n */\nfunction moveSvg(props, position) {\n  const elementBBox = props.elementBBox;\n  if (position.left !== elementBBox.left || position.top !== elementBBox.top) {\n    const offset = props.svgOffset,\n      originBBox = props.svgOriginBBox,\n      point = viewPoint2SvgPoint(\n        props,\n        position.left - window.pageXOffset,\n        position.top - window.pageYOffset,\n      );\n    props.svgTransform.setTranslate(\n      point.x + offset.x - originBBox.x,\n      point.y + offset.y - originBBox.y,\n    );\n    return true;\n  }\n  return false;\n}\n// [/SVG]\n\n/**\n * Set `props.element` position.\n * @param {props} props - `props` of instance.\n * @param {{left: number, top: number}} position - New position.\n * @param {function} [cbCheck] - Callback that is called with valid position, cancel moving if it returns `false`.\n * @returns {boolean} `true` if it was moved.\n */\nfunction move(props, position, cbCheck = null) {\n  const elementBBox = props.elementBBox;\n\n  function fix() {\n    if (props.minLeft >= props.maxLeft) {\n      // Disabled\n      position.left = elementBBox.left;\n    } else if (position.left < props.minLeft) {\n      position.left = props.minLeft;\n    } else if (position.left > props.maxLeft) {\n      position.left = props.maxLeft;\n    }\n    if (props.minTop >= props.maxTop) {\n      // Disabled\n      position.top = elementBBox.top;\n    } else if (position.top < props.minTop) {\n      position.top = props.minTop;\n    } else if (position.top > props.maxTop) {\n      position.top = props.maxTop;\n    }\n  }\n\n  fix();\n  if (cbCheck) {\n    if (cbCheck(position) === false) {\n      return false;\n    }\n    fix(); // Again\n  }\n\n  const moved = props.moveElm(props, position);\n  if (moved) {\n    // Update elementBBox\n    props.elementBBox = validBBox({\n      left: position.left,\n      top: position.top,\n      width: elementBBox.width,\n      height: elementBBox.height,\n    });\n  }\n  return moved;\n}\n\n/**\n * Initialize HTMLElement for `translate`, and get `offset` that is used by `moveTranslate`.\n * @param {props} props - `props` of instance.\n * @returns {BBox} Current BBox without animation, i.e. left/top properties.\n */\nfunction initTranslate(props) {\n  const element = props.element,\n    elementStyle = props.elementStyle,\n    curPosition = getBBox(element), // Get BBox before change style.\n    RESTORE_PROPS = ['display', 'marginTop', 'marginBottom', 'width', 'height'];\n  RESTORE_PROPS.unshift(cssPropTransform);\n\n  // Reset `transition-property` every time because it might be changed frequently.\n  const orgTransitionProperty = elementStyle[cssPropTransitionProperty];\n  elementStyle[cssPropTransitionProperty] = 'none'; // Disable animation\n  const fixPosition = getBBox(element);\n\n  if (!props.orgStyle) {\n    props.orgStyle = RESTORE_PROPS.reduce((orgStyle, prop) => {\n      orgStyle[prop] = elementStyle[prop] || '';\n      return orgStyle;\n    }, {});\n    props.lastStyle = {};\n  } else {\n    RESTORE_PROPS.forEach(prop => {\n      // Skip this if it seems user changed it. (it can't check perfectly.)\n      if (\n        props.lastStyle[prop] == null ||\n        elementStyle[prop] === props.lastStyle[prop]\n      ) {\n        elementStyle[prop] = props.orgStyle[prop];\n      }\n    });\n  }\n\n  const orgSize = getBBox(element),\n    cmpStyle = window.getComputedStyle(element, '');\n  // https://www.w3.org/TR/css-transforms-1/#transformable-element\n  if (cmpStyle.display === 'inline') {\n    elementStyle.display = 'inline-block';\n    ['Top', 'Bottom'].forEach(dirProp => {\n      const padding = parseFloat(cmpStyle[`padding${dirProp}`]);\n      // paddingTop/Bottom make padding but don't make space -> negative margin in inline-block\n      // marginTop/Bottom don't work in inline element -> `0` in inline-block\n      elementStyle[`margin${dirProp}`] = padding ? `-${padding}px` : '0';\n    });\n  }\n  elementStyle[cssPropTransform] = 'translate(0, 0)';\n  // Get document offset.\n  let newBBox = getBBox(element);\n  const offset = (props.htmlOffset = {\n    left: newBBox.left ? -newBBox.left : 0,\n    top: newBBox.top ? -newBBox.top : 0,\n  }); // avoid `-0`\n\n  // Restore position\n  elementStyle[cssPropTransform] = `translate(${curPosition.left +\n    offset.left}px, ${curPosition.top + offset.top}px)`;\n  // Restore size\n  ['width', 'height'].forEach(prop => {\n    if (newBBox[prop] !== orgSize[prop]) {\n      // Ignore `box-sizing`\n      elementStyle[prop] = orgSize[prop] + 'px';\n      newBBox = getBBox(element);\n      if (newBBox[prop] !== orgSize[prop]) {\n        // Retry\n        elementStyle[prop] =\n          orgSize[prop] - (newBBox[prop] - orgSize[prop]) + 'px';\n      }\n    }\n    props.lastStyle[prop] = elementStyle[prop];\n  });\n\n  // Restore `transition-property`\n  element.offsetWidth; /* force reflow */ // eslint-disable-line no-unused-expressions\n  elementStyle[cssPropTransitionProperty] = orgTransitionProperty;\n  if (\n    fixPosition.left !== curPosition.left ||\n    fixPosition.top !== curPosition.top\n  ) {\n    // It seems that it is moving.\n    elementStyle[cssPropTransform] = `translate(${fixPosition.left +\n      offset.left}px, ${fixPosition.top + offset.top}px)`;\n  }\n\n  return fixPosition;\n}\n\n// [LEFTTOP]\n/**\n * Initialize HTMLElement for `left` and `top`, and get `offset` that is used by `moveLeftTop`.\n * @param {props} props - `props` of instance.\n * @returns {BBox} Current BBox without animation, i.e. left/top properties.\n */\nfunction initLeftTop(props) {\n  const element = props.element,\n    elementStyle = props.elementStyle,\n    curPosition = getBBox(element), // Get BBox before change style.\n    RESTORE_PROPS = [\n      'position',\n      'marginTop',\n      'marginRight',\n      'marginBottom',\n      'marginLeft',\n      'width',\n      'height',\n    ];\n\n  // Reset `transition-property` every time because it might be changed frequently.\n  const orgTransitionProperty = elementStyle[cssPropTransitionProperty];\n  elementStyle[cssPropTransitionProperty] = 'none'; // Disable animation\n  const fixPosition = getBBox(element);\n\n  if (!props.orgStyle) {\n    props.orgStyle = RESTORE_PROPS.reduce((orgStyle, prop) => {\n      orgStyle[prop] = elementStyle[prop] || '';\n      return orgStyle;\n    }, {});\n    props.lastStyle = {};\n  } else {\n    RESTORE_PROPS.forEach(prop => {\n      // Skip this if it seems user changed it. (it can't check perfectly.)\n      if (\n        props.lastStyle[prop] == null ||\n        elementStyle[prop] === props.lastStyle[prop]\n      ) {\n        elementStyle[prop] = props.orgStyle[prop];\n      }\n    });\n  }\n\n  const orgSize = getBBox(element);\n  elementStyle.position = 'absolute';\n  elementStyle.left = elementStyle.top = elementStyle.margin = '0';\n  // Get document offset.\n  let newBBox = getBBox(element);\n  const offset = (props.htmlOffset = {\n    left: newBBox.left ? -newBBox.left : 0,\n    top: newBBox.top ? -newBBox.top : 0,\n  }); // avoid `-0`\n\n  // Restore position\n  elementStyle.left = curPosition.left + offset.left + 'px';\n  elementStyle.top = curPosition.top + offset.top + 'px';\n  // Restore size\n  ['width', 'height'].forEach(prop => {\n    if (newBBox[prop] !== orgSize[prop]) {\n      // Ignore `box-sizing`\n      elementStyle[prop] = orgSize[prop] + 'px';\n      newBBox = getBBox(element);\n      if (newBBox[prop] !== orgSize[prop]) {\n        // Retry\n        elementStyle[prop] =\n          orgSize[prop] - (newBBox[prop] - orgSize[prop]) + 'px';\n      }\n    }\n    props.lastStyle[prop] = elementStyle[prop];\n  });\n\n  // Restore `transition-property`\n  element.offsetWidth; /* force reflow */ // eslint-disable-line no-unused-expressions\n  elementStyle[cssPropTransitionProperty] = orgTransitionProperty;\n  if (\n    fixPosition.left !== curPosition.left ||\n    fixPosition.top !== curPosition.top\n  ) {\n    // It seems that it is moving.\n    elementStyle.left = fixPosition.left + offset.left + 'px';\n    elementStyle.top = fixPosition.top + offset.top + 'px';\n  }\n\n  return fixPosition;\n}\n// [/LEFTTOP]\n\n// [SVG]\n/**\n * Initialize SVGElement, and get `offset` that is used by `moveSvg`.\n * @param {props} props - `props` of instance.\n * @returns {BBox} Current BBox without animation, i.e. left/top properties.\n */\nfunction initSvg(props) {\n  const element = props.element,\n    svgTransform = props.svgTransform,\n    curRect = element.getBoundingClientRect(), // Get Rect before change position.\n    fixPosition = getBBox(element);\n\n  svgTransform.setTranslate(0, 0);\n  const originBBox = (props.svgOriginBBox = element.getBBox()),\n    // Try to get SVG coordinates of current position.\n    newRect = element.getBoundingClientRect(),\n    originPoint = viewPoint2SvgPoint(props, newRect.left, newRect.top),\n    // Gecko bug, getScreenCTM returns incorrect CTM, and originPoint might not be current position.\n    offset = (props.svgOffset = {\n      x: originBBox.x - originPoint.x,\n      y: originBBox.y - originPoint.y,\n    }),\n    // Restore position\n    curPoint = viewPoint2SvgPoint(props, curRect.left, curRect.top);\n  svgTransform.setTranslate(\n    curPoint.x + offset.x - originBBox.x,\n    curPoint.y + offset.y - originBBox.y,\n  );\n\n  return fixPosition;\n}\n// [/SVG]\n\n/**\n * Set `elementBBox`, `containmentBBox`, `min/max``Left/Top` and `snapTargets`.\n * @param {props} props - `props` of instance.\n * @param {string} [eventType] - A type of event that kicked this method.\n * @returns {void}\n */\nfunction initBBox(props, eventType = '') {\n  // eslint-disable-line no-unused-vars\n  const docBBox = getBBox(document.documentElement),\n    elementBBox = (props.elementBBox = props.initElm(props)), // reset offset etc.\n    containmentBBox = (props.containmentBBox = props.containmentIsBBox\n      ? resolvePPBBox(props.options.containment, docBBox) || docBBox\n      : getBBox(props.options.containment, true));\n  props.minLeft = containmentBBox.left;\n  props.maxLeft = containmentBBox.right - elementBBox.width;\n  props.minTop = containmentBBox.top;\n  props.maxTop = containmentBBox.bottom - elementBBox.height;\n  // Adjust position\n  move(props, { left: elementBBox.left, top: elementBBox.top });\n\n  // [SNAP]\n\n  // Snap-targets\n\n  /**\n   * @typedef {Object} SnapTarget\n   * @property {number} [x] - A coordinate it moves to. It has x or y or both.\n   * @property {number} [y]\n   * @property {number} [gravityXStart] - Gravity zone. It has *Start or *End or both, and *X* or *Y* or both.\n   * @property {number} [gravityXEnd]\n   * @property {number} [gravityYStart]\n   * @property {number} [gravityYEnd]\n   */\n\n  if (props.parsedSnapTargets) {\n    const elementSizeXY = { x: elementBBox.width, y: elementBBox.height },\n      minXY = { x: props.minLeft, y: props.minTop },\n      maxXY = { x: props.maxLeft, y: props.maxTop },\n      prop2Axis = {\n        left: 'x',\n        right: 'x',\n        x: 'x',\n        width: 'x',\n        xStart: 'x',\n        xEnd: 'x',\n        xStep: 'x',\n        top: 'y',\n        bottom: 'y',\n        y: 'y',\n        height: 'y',\n        yStart: 'y',\n        yEnd: 'y',\n        yStep: 'y',\n      },\n      snapTargets = props.parsedSnapTargets.reduce(\n        (snapTargets, parsedSnapTarget) => {\n          const baseRect =\n              parsedSnapTarget.base === 'containment'\n                ? containmentBBox\n                : docBBox,\n            baseOriginXY = { x: baseRect.left, y: baseRect.top },\n            baseSizeXY = { x: baseRect.width, y: baseRect.height };\n\n          /**\n           * Basically, shallow copy from parsedSnapTarget, and it can have resolved values.\n           * @typedef {{x: (number|PPValue), y, xStart, xEnd, xStep, yStart, yEnd, yStep}} TargetXY\n           * @property {string[]} [corners] - Applied value.\n           * @property {string[]} [sides]\n           * @property {boolean} center\n           * @property {number} [xGravity] - Override parsedSnapTarget.gravity.\n           * @property {number} [yGravity]\n           */\n\n          // Add single Point or Line (i.e. targetXY has no *Step)\n          function addSnapTarget(targetXY) {\n            if (targetXY.center == null) {\n              targetXY.center = parsedSnapTarget.center;\n            }\n            if (targetXY.xGravity == null) {\n              targetXY.xGravity = parsedSnapTarget.gravity;\n            }\n            if (targetXY.yGravity == null) {\n              targetXY.yGravity = parsedSnapTarget.gravity;\n            }\n\n            if (targetXY.x != null && targetXY.y != null) {\n              // Point\n              targetXY.x = resolvePPValue(\n                targetXY.x,\n                baseOriginXY.x,\n                baseSizeXY.x,\n              );\n              targetXY.y = resolvePPValue(\n                targetXY.y,\n                baseOriginXY.y,\n                baseSizeXY.y,\n              );\n\n              if (targetXY.center) {\n                targetXY.x -= elementSizeXY.x / 2;\n                targetXY.y -= elementSizeXY.y / 2;\n                targetXY.corners = ['tl'];\n              }\n\n              (targetXY.corners || parsedSnapTarget.corners).forEach(corner => {\n                const x =\n                    targetXY.x -\n                    (corner === 'tr' || corner === 'br' ? elementSizeXY.x : 0),\n                  y =\n                    targetXY.y -\n                    (corner === 'bl' || corner === 'br' ? elementSizeXY.y : 0);\n                if (\n                  x >= minXY.x &&\n                  x <= maxXY.x &&\n                  y >= minXY.y &&\n                  y <= maxXY.y\n                ) {\n                  const snapTarget: any = { x, y },\n                    gravityXStart = x - targetXY.xGravity,\n                    gravityXEnd = x + targetXY.xGravity,\n                    gravityYStart = y - targetXY.yGravity,\n                    gravityYEnd = y + targetXY.yGravity;\n                  if (gravityXStart > minXY.x) {\n                    snapTarget.gravityXStart = gravityXStart;\n                  }\n                  if (gravityXEnd < maxXY.x) {\n                    snapTarget.gravityXEnd = gravityXEnd;\n                  }\n                  if (gravityYStart > minXY.y) {\n                    snapTarget.gravityYStart = gravityYStart;\n                  }\n                  if (gravityYEnd < maxXY.y) {\n                    snapTarget.gravityYEnd = gravityYEnd;\n                  }\n                  snapTargets.push(snapTarget);\n                }\n              });\n            } else {\n              // Line\n              const specAxis = targetXY.x != null ? 'x' : 'y',\n                rangeAxis = specAxis === 'x' ? 'y' : 'x',\n                startProp = `${rangeAxis}Start`,\n                endProp = `${rangeAxis}End`,\n                gravityProp = `${specAxis}Gravity`,\n                specAxisL = specAxis.toUpperCase(),\n                rangeAxisL = rangeAxis.toUpperCase(),\n                gravitySpecStartProp = `gravity${specAxisL}Start`,\n                gravitySpecEndProp = `gravity${specAxisL}End`,\n                gravityRangeStartProp = `gravity${rangeAxisL}Start`,\n                gravityRangeEndProp = `gravity${rangeAxisL}End`;\n              targetXY[specAxis] = resolvePPValue(\n                targetXY[specAxis],\n                baseOriginXY[specAxis],\n                baseSizeXY[specAxis],\n              );\n              targetXY[startProp] = resolvePPValue(\n                targetXY[startProp],\n                baseOriginXY[rangeAxis],\n                baseSizeXY[rangeAxis],\n              );\n              targetXY[endProp] =\n                resolvePPValue(\n                  targetXY[endProp],\n                  baseOriginXY[rangeAxis],\n                  baseSizeXY[rangeAxis],\n                ) - elementSizeXY[rangeAxis]; // Reduce the end of the line.\n              if (\n                targetXY[startProp] > targetXY[endProp] || // Smaller than element size.\n                targetXY[startProp] > maxXY[rangeAxis] ||\n                targetXY[endProp] < minXY[rangeAxis]\n              ) {\n                return;\n              }\n\n              if (targetXY.center) {\n                targetXY[specAxis] -= elementSizeXY[specAxis] / 2;\n                targetXY.sides = ['start'];\n              }\n\n              (targetXY.sides || parsedSnapTarget.sides).forEach(side => {\n                const xy =\n                  targetXY[specAxis] -\n                  (side === 'end' ? elementSizeXY[specAxis] : 0);\n                if (xy >= minXY[specAxis] && xy <= maxXY[specAxis]) {\n                  const snapTarget = {},\n                    gravitySpecStart = xy - targetXY[gravityProp],\n                    gravitySpecEnd = xy + targetXY[gravityProp];\n                  snapTarget[specAxis] = xy;\n                  if (gravitySpecStart > minXY[specAxis]) {\n                    snapTarget[gravitySpecStartProp] = gravitySpecStart;\n                  }\n                  if (gravitySpecEnd < maxXY[specAxis]) {\n                    snapTarget[gravitySpecEndProp] = gravitySpecEnd;\n                  }\n                  if (targetXY[startProp] > minXY[rangeAxis]) {\n                    snapTarget[gravityRangeStartProp] = targetXY[startProp];\n                  }\n                  if (targetXY[endProp] < maxXY[rangeAxis]) {\n                    snapTarget[gravityRangeEndProp] = targetXY[endProp];\n                  }\n                  snapTargets.push(snapTarget);\n                }\n              });\n            }\n          }\n\n          let bBox;\n          if (\n            (bBox = parsedSnapTarget.element\n              ? getBBox(parsedSnapTarget.element)\n              : null) || // Element\n            parsedSnapTarget.ppBBox\n          ) {\n            if (parsedSnapTarget.ppBBox) {\n              bBox = resolvePPBBox(parsedSnapTarget.ppBBox, baseRect);\n            } // BBox\n            if (bBox) {\n              // Drop invalid BBox.\n              // Expand into 4 lines.\n              parsedSnapTarget.edges.forEach(edge => {\n                let lengthenX = parsedSnapTarget.gravity,\n                  lengthenY = parsedSnapTarget.gravity;\n                if (edge === 'outside') {\n                  // Snap it when a part of the element is part of the range.\n                  lengthenX += elementBBox.width;\n                  lengthenY += elementBBox.height;\n                }\n                const xStart = bBox.left - lengthenX,\n                  xEnd = bBox.right + lengthenX,\n                  yStart = bBox.top - lengthenY,\n                  yEnd = bBox.bottom + lengthenY;\n                let side = edge === 'inside' ? 'start' : 'end';\n                addSnapTarget({\n                  xStart,\n                  xEnd,\n                  y: bBox.top,\n                  sides: [side],\n                  center: false,\n                }); // Top\n                addSnapTarget({\n                  x: bBox.left,\n                  yStart,\n                  yEnd,\n                  sides: [side],\n                  center: false,\n                }); // Left\n                side = edge === 'inside' ? 'end' : 'start';\n                addSnapTarget({\n                  xStart,\n                  xEnd,\n                  y: bBox.bottom,\n                  sides: [side],\n                  center: false,\n                }); // Bottom\n                addSnapTarget({\n                  x: bBox.right,\n                  yStart,\n                  yEnd,\n                  sides: [side],\n                  center: false,\n                }); // Right\n              });\n            }\n          } else {\n            let expanded: any = [\n              [\n                'x',\n                'y',\n                'xStart',\n                'xEnd',\n                'xStep',\n                'yStart',\n                'yEnd',\n                'yStep',\n              ].reduce((targetXY, prop) => {\n                if (parsedSnapTarget[prop]) {\n                  targetXY[prop] = resolvePPValue(\n                    parsedSnapTarget[prop],\n                    prop === 'xStep' || prop === 'yStep'\n                      ? 0\n                      : baseOriginXY[prop2Axis[prop]],\n                    baseSizeXY[prop2Axis[prop]],\n                  );\n                }\n                return targetXY;\n              }, {}),\n            ];\n\n            ['x', 'y'].forEach(axis => {\n              const startProp = `${axis}Start`,\n                endProp = `${axis}End`,\n                stepProp = `${axis}Step`,\n                gravityProp = `${axis}Gravity`;\n              expanded = expanded.reduce((expanded, targetXY) => {\n                const start = targetXY[startProp],\n                  end = targetXY[endProp],\n                  step = targetXY[stepProp];\n                if (start != null && end != null && start >= end) {\n                  return expanded;\n                } // start >= end\n\n                if (step != null) {\n                  if (step < 2) {\n                    return expanded;\n                  }\n                  // step >= 2px -> Expand by step\n                  let gravity = step / 2; // max\n                  gravity = parsedSnapTarget.gravity > gravity ? gravity : null;\n                  for (\n                    let curValue = start;\n                    curValue <= end;\n                    curValue += step\n                  ) {\n                    const expandedXY = Object.keys(targetXY).reduce(\n                      (expandedXY, prop) => {\n                        if (\n                          prop !== startProp &&\n                          prop !== endProp &&\n                          prop !== stepProp\n                        ) {\n                          expandedXY[prop] = targetXY[prop];\n                        }\n                        return expandedXY;\n                      },\n                      {},\n                    );\n                    expandedXY[axis] = curValue;\n                    expandedXY[gravityProp] = gravity;\n                    expanded.push(expandedXY);\n                  }\n                } else {\n                  expanded.push(targetXY);\n                }\n                return expanded;\n              }, []);\n            });\n            expanded.forEach(targetXY => {\n              addSnapTarget(targetXY);\n            });\n          }\n\n          return snapTargets;\n        },\n        [],\n      );\n\n    props.snapTargets = snapTargets.length ? snapTargets : null;\n  }\n  // [/SNAP]\n\n  // [AUTO-SCROLL]\n  const autoScroll: any = {},\n    autoScrollOptions = props.options.autoScroll;\n  if (autoScrollOptions) {\n    autoScroll.isWindow = autoScrollOptions.target === window;\n    autoScroll.target = autoScrollOptions.target;\n\n    const dontScroll = eventType === 'scroll', // Avoid duplicated calling\n      scrollable = getScrollable(\n        autoScrollOptions.target,\n        autoScroll.isWindow,\n        dontScroll,\n      ),\n      scrollableBBox = validBBox({\n        left: scrollable.clientX,\n        top: scrollable.clientY,\n        width: scrollable.clientWidth,\n        height: scrollable.clientHeight,\n      });\n    autoScroll.scrollableBBox = scrollableBBox; // [DEBUG/]\n\n    if (!dontScroll) {\n      autoScroll.scrollWidth = scrollable.scrollWidth;\n      autoScroll.scrollHeight = scrollable.scrollHeight;\n    } else if (props.autoScroll) {\n      autoScroll.scrollWidth = props.autoScroll.scrollWidth;\n      autoScroll.scrollHeight = props.autoScroll.scrollHeight;\n    }\n\n    [['X', 'Width', 'left', 'right'], ['Y', 'Height', 'top', 'bottom']].forEach(\n      axis => {\n        const xy = axis[0],\n          wh = axis[1],\n          back = axis[2],\n          forward = axis[3],\n          maxAbs = (autoScroll[`scroll${wh}`] || 0) - scrollable[`client${wh}`],\n          min = autoScrollOptions[`min${xy}`] || 0;\n        let max = isFinite(autoScrollOptions[`max${xy}`])\n          ? autoScrollOptions[`max${xy}`]\n          : maxAbs;\n        if (min < max && min < maxAbs) {\n          if (max > maxAbs) {\n            max = maxAbs;\n          }\n\n          const lines = [],\n            elementSize = elementBBox[wh.toLowerCase()];\n          for (let i = autoScrollOptions.sensitivity.length - 1; i >= 0; i--) {\n            // near -> far\n            const sensitivity = autoScrollOptions.sensitivity[i],\n              speed = autoScrollOptions.speed[i];\n            // back\n            lines.push({\n              dir: -1,\n              speed,\n              position: scrollableBBox[back] + sensitivity,\n            });\n            // forward\n            lines.push({\n              dir: 1,\n              speed,\n              position: scrollableBBox[forward] - sensitivity - elementSize,\n            });\n          }\n\n          autoScroll[xy.toLowerCase()] = { min, max, lines };\n        }\n      },\n    );\n  }\n  props.autoScroll = autoScroll.x || autoScroll.y ? autoScroll : null;\n  // [/AUTO-SCROLL]\n}\n\n/**\n * @param {props} props - `props` of instance.\n * @returns {void}\n */\nfunction dragEnd(props) {\n  scrollFrame.stop(); // [AUTO-SCROLL/]\n  setDraggableCursor(props.options.handle, props.orgCursor);\n  body.style.cursor = cssOrgValueBodyCursor;\n\n  if (props.options.zIndex !== false) {\n    props.elementStyle.zIndex = props.orgZIndex;\n  }\n  if (cssPropUserSelect) {\n    body.style[cssPropUserSelect] = cssOrgValueBodyUserSelect;\n  }\n  const classList = mClassList(props.element);\n  if (movingClass) {\n    classList.remove(movingClass);\n  }\n  if (draggingClass) {\n    classList.remove(draggingClass);\n  }\n\n  activeProps = null;\n  pointerEvent.cancel(); // Reset pointer (activeProps must be null because this calls endHandler)\n  if (props.onDragEnd) {\n    props.onDragEnd({\n      left: props.elementBBox.left,\n      top: props.elementBBox.top,\n    });\n  }\n}\n\n/**\n * @param {props} props - `props` of instance.\n * @param {{clientX, clientY}} pointerXY - This might be MouseEvent, Touch of TouchEvent or Object.\n * @returns {boolean} `true` if it started.\n */\nfunction dragStart(props, pointerXY) {\n  if (props.disabled) {\n    return false;\n  }\n  if (props.onDragStart && props.onDragStart(pointerXY) === false) {\n    return false;\n  }\n  if (activeProps) {\n    dragEnd(activeProps);\n  } // activeItem is normally null by pointerEvent.end.\n\n  setDraggingCursor(props.options.handle);\n  body.style.cursor =\n    cssValueDraggingCursor || // If it is `false` or `''`\n    window.getComputedStyle(props.options.handle, '').cursor;\n\n  if (props.options.zIndex !== false) {\n    props.elementStyle.zIndex = props.options.zIndex;\n  }\n  if (cssPropUserSelect) {\n    body.style[cssPropUserSelect] = 'none';\n  }\n  if (draggingClass) {\n    mClassList(props.element).add(draggingClass);\n  }\n\n  activeProps = props;\n  hasMoved = false;\n  pointerOffset.left =\n    props.elementBBox.left - (pointerXY.clientX + window.pageXOffset);\n  pointerOffset.top =\n    props.elementBBox.top - (pointerXY.clientY + window.pageYOffset);\n  return true;\n}\n\n/**\n * @param {props} props - `props` of instance.\n * @param {Object} newOptions - New options.\n * @returns {void}\n */\nfunction setOptions(props, newOptions) {\n  const options = props.options;\n  let needsInitBBox;\n\n  // containment\n  if (newOptions.containment) {\n    let bBox;\n    if (isElement(newOptions.containment)) {\n      // Specific element\n      if (newOptions.containment !== options.containment) {\n        options.containment = newOptions.containment;\n        props.containmentIsBBox = false;\n        needsInitBBox = true;\n      }\n    } else if (\n      (bBox = validPPBBox(copyTree(newOptions.containment))) && // bBox\n      hasChanged(bBox, options.containment)\n    ) {\n      options.containment = bBox;\n      props.containmentIsBBox = true;\n      needsInitBBox = true;\n    }\n  }\n\n  // [SNAP]\n\n  /**\n   * @typedef {Object} SnapOptions\n   * @property {SnapTargetOptions[]} targets\n   * @property {number} [gravity]\n   * @property {string} [corner]\n   * @property {string} [side]\n   * @property {boolean} [center]\n   * @property {string} [edge]\n   * @property {string} [base]\n   */\n\n  /**\n   * @typedef {Object} SnapTargetOptions\n   * @property {(number|string)} [x] - pixels | '<n>%' | {start, end} | {step, start, end}\n   * @property {(number|string)} [y]\n   * @property {(Element|Object)} [boundingBox] - Object has properties that are string or number from PPBBox.\n   * @property {number} [gravity]\n   * @property {string} [corner]\n   * @property {string} [side]\n   * @property {boolean} [center]\n   * @property {string} [edge]\n   * @property {string} [base]\n   */\n\n  /**\n   * @typedef {Object} ParsedSnapTarget\n   * @property {PPValue} [x] - (input: pixels | '<n>%')\n   * @property {PPValue} [y]\n   * @property {PPValue} [xStart] - (input: {start, end} | {step, start, end})\n   * @property {PPValue} [xEnd]\n   * @property {PPValue} [xStep] - (input: {step, start, end})\n   * @property {PPValue} [yStart]\n   * @property {PPValue} [yEnd]\n   * @property {PPValue} [yStep]\n   * @property {Element} [element]\n   * @property {PPBBox} [ppBBox]\n   * @property {number} gravity\n   * @property {string[]} corners\n   * @property {string[]} sides\n   * @property {boolean} center\n   * @property {string[]} edges\n   * @property {string} base\n   */\n\n  // Normalize `gravity`, `corner`, `side`, `center`, `edge`, `base`\n  function commonSnapOptions(options, newOptions) {\n    function cleanString(inString) {\n      return typeof inString === 'string'\n        ? inString\n            .replace(/[, ]+/g, ' ')\n            .trim()\n            .toLowerCase()\n        : null;\n    }\n\n    // gravity\n    if (isFinite(newOptions.gravity) && newOptions.gravity > 0) {\n      options.gravity = newOptions.gravity;\n    }\n    // corner\n    let corner = cleanString(newOptions.corner);\n    if (corner) {\n      if (corner !== 'all') {\n        const added = {},\n          corners = corner.split(/\\s/).reduce((corners, corner) => {\n            corner = corner.trim().replace(/^(.).*?-(.).*$/, '$1$2');\n            if (\n              (corner =\n                corner === 'tl' || corner === 'lt'\n                  ? 'tl'\n                  : corner === 'tr' || corner === 'rt'\n                  ? 'tr'\n                  : corner === 'bl' || corner === 'lb'\n                  ? 'bl'\n                  : corner === 'br' || corner === 'rb'\n                  ? 'br'\n                  : null) &&\n              !added[corner]\n            ) {\n              corners.push(corner);\n              added[corner] = true;\n            }\n            return corners;\n          }, []),\n          cornersLen = corners.length;\n        corner = !cornersLen\n          ? null\n          : cornersLen === 4\n          ? 'all'\n          : corners.join(' ');\n      }\n      if (corner) {\n        options.corner = corner;\n      }\n    }\n    // side\n    const side = cleanString(newOptions.side);\n    if (side) {\n      if (side === 'start' || side === 'end' || side === 'both') {\n        options.side = side;\n      } else if (side === 'start end' || side === 'end start') {\n        options.side = 'both';\n      }\n    }\n    // center\n    if (typeof newOptions.center === 'boolean') {\n      options.center = newOptions.center;\n    }\n    // edge\n    const edge = cleanString(newOptions.edge);\n    if (edge) {\n      if (edge === 'inside' || edge === 'outside' || edge === 'both') {\n        options.edge = edge;\n      } else if (edge === 'inside outside' || edge === 'outside inside') {\n        options.edge = 'both';\n      }\n    }\n    // base\n    const base =\n      typeof newOptions.base === 'string'\n        ? newOptions.base.trim().toLowerCase()\n        : null;\n    if (base && (base === 'containment' || base === 'document')) {\n      options.base = base;\n    }\n    return options;\n  }\n\n  // snap\n  if (newOptions.snap != null) {\n    const newSnapOptions =\n        isObject(newOptions.snap) && newOptions.snap.targets != null\n          ? newOptions.snap\n          : { targets: newOptions.snap },\n      snapTargetsOptions = [],\n      snapOptions = commonSnapOptions(\n        { targets: snapTargetsOptions },\n        newSnapOptions,\n      );\n\n    // Set default options into top level.\n    if (!snapOptions.gravity) {\n      snapOptions.gravity = SNAP_GRAVITY;\n    }\n    if (!snapOptions.corner) {\n      snapOptions.corner = SNAP_CORNER;\n    }\n    if (!snapOptions.side) {\n      snapOptions.side = SNAP_SIDE;\n    }\n    if (typeof snapOptions.center !== 'boolean') {\n      snapOptions.center = false;\n    }\n    if (!snapOptions.edge) {\n      snapOptions.edge = SNAP_EDGE;\n    }\n    if (!snapOptions.base) {\n      snapOptions.base = SNAP_BASE;\n    }\n\n    const parsedSnapTargets = (Array.isArray(newSnapOptions.targets)\n      ? newSnapOptions.targets\n      : [newSnapOptions.targets]\n    ).reduce((parsedSnapTargets, target) => {\n      if (target == null) {\n        return parsedSnapTargets;\n      }\n\n      const isElementPre = isElement(target), // Pre-check direct value\n        ppBBoxPre = validPPBBox(copyTree(target)), // Pre-check direct value\n        newSnapTargetOptions =\n          isElementPre || ppBBoxPre\n            ? { boundingBox: target } // Direct Element | PPBBox\n            : isObject(target) &&\n              target.start == null &&\n              target.end == null &&\n              target.step == null\n            ? target // SnapTargetOptions\n            : { x: target, y: target }, // Others, it might be {step, start, end}\n        expandedParsedSnapTargets = [],\n        snapTargetOptions: any = {},\n        newOptionsBBox = newSnapTargetOptions.boundingBox;\n      let ppBBox;\n\n      if (isElementPre || isElement(newOptionsBBox)) {\n        // Element\n        expandedParsedSnapTargets.push({ element: newOptionsBBox });\n        snapTargetOptions.boundingBox = newOptionsBBox;\n      } else if (\n        (ppBBox = ppBBoxPre || validPPBBox(copyTree(newOptionsBBox)))\n      ) {\n        // Object -> PPBBox\n        expandedParsedSnapTargets.push({ ppBBox });\n        snapTargetOptions.boundingBox = ppBBox2OptionObject(ppBBox);\n      } else {\n        let invalid; // `true` if valid PPValue was given but the contained value is invalid.\n        const parsedXY: any = ['x', 'y'].reduce((parsedXY, axis) => {\n          const newOptionsXY = newSnapTargetOptions[axis];\n          let ppValue;\n\n          if ((ppValue = validPPValue(newOptionsXY))) {\n            // pixels | '<n>%'\n            parsedXY[axis] = ppValue;\n            snapTargetOptions[axis] = ppValue2OptionValue(ppValue);\n          } else {\n            // {start, end} | {step, start, end}\n            let start, end, step;\n            if (isObject(newOptionsXY)) {\n              start = validPPValue(newOptionsXY.start);\n              end = validPPValue(newOptionsXY.end);\n              step = validPPValue(newOptionsXY.step);\n              if (\n                start &&\n                end &&\n                start.isRatio === end.isRatio &&\n                start.value >= end.value\n              ) {\n                // start >= end\n                invalid = true;\n              }\n            }\n            start = parsedXY[`${axis}Start`] = start || {\n              value: 0,\n              isRatio: false,\n            };\n            end = parsedXY[`${axis}End`] = end || { value: 1, isRatio: true };\n            snapTargetOptions[axis] = {\n              start: ppValue2OptionValue(start),\n              end: ppValue2OptionValue(end),\n            };\n            if (step) {\n              if (step.isRatio ? step.value > 0 : step.value >= 2) {\n                // step > 0% || step >= 2px\n                parsedXY[`${axis}Step`] = step;\n                snapTargetOptions[axis].step = ppValue2OptionValue(step);\n              } else {\n                invalid = true;\n              }\n            }\n          }\n          return parsedXY;\n        }, {});\n        if (invalid) {\n          return parsedSnapTargets;\n        }\n\n        if (\n          parsedXY.xStart &&\n          !parsedXY.xStep &&\n          parsedXY.yStart &&\n          !parsedXY.yStep\n        ) {\n          // Expand into 4 lines. This is not BBox, and `edge` is ignored.\n          expandedParsedSnapTargets.push(\n            {\n              xStart: parsedXY.xStart,\n              xEnd: parsedXY.xEnd,\n              y: parsedXY.yStart,\n            }, // Top\n            { xStart: parsedXY.xStart, xEnd: parsedXY.xEnd, y: parsedXY.yEnd }, // Bottom\n            {\n              x: parsedXY.xStart,\n              yStart: parsedXY.yStart,\n              yEnd: parsedXY.yEnd,\n            }, // Left\n            { x: parsedXY.xEnd, yStart: parsedXY.yStart, yEnd: parsedXY.yEnd }, // Right\n          );\n        } else {\n          expandedParsedSnapTargets.push(parsedXY);\n        }\n      }\n\n      if (expandedParsedSnapTargets.length) {\n        snapTargetsOptions.push(\n          commonSnapOptions(snapTargetOptions, newSnapTargetOptions),\n        );\n        // Copy common SnapOptions\n        const corner = snapTargetOptions.corner || snapOptions.corner,\n          side = snapTargetOptions.side || snapOptions.side,\n          edge = snapTargetOptions.edge || snapOptions.edge,\n          commonOptions = {\n            gravity: snapTargetOptions.gravity || snapOptions.gravity,\n            base: snapTargetOptions.base || snapOptions.base,\n            center:\n              typeof snapTargetOptions.center === 'boolean'\n                ? snapTargetOptions.center\n                : snapOptions.center,\n            corners: corner === 'all' ? SNAP_ALL_CORNERS : corner.split(' '), // Split\n            sides: side === 'both' ? SNAP_ALL_SIDES : [side], // Split\n            edges: edge === 'both' ? SNAP_ALL_EDGES : [edge], // Split\n          };\n        expandedParsedSnapTargets.forEach(parsedSnapTarget => {\n          // Set common SnapOptions\n          ['gravity', 'corners', 'sides', 'center', 'edges', 'base'].forEach(\n            option => {\n              parsedSnapTarget[option] = commonOptions[option];\n            },\n          );\n          parsedSnapTargets.push(parsedSnapTarget);\n        });\n      }\n      return parsedSnapTargets;\n    }, []);\n\n    if (parsedSnapTargets.length) {\n      options.snap = snapOptions; // Update always\n      if (hasChanged(parsedSnapTargets, props.parsedSnapTargets)) {\n        props.parsedSnapTargets = parsedSnapTargets;\n        needsInitBBox = true;\n      }\n    }\n  } else if (newOptions.hasOwnProperty('snap') && props.parsedSnapTargets) {\n    options.snap = props.parsedSnapTargets = props.snapTargets = void 0;\n  }\n\n  // [/SNAP]\n\n  // [AUTO-SCROLL]\n\n  /**\n   * @typedef {Object} AutoScrollOptions\n   * @property {(Element|Window)} target\n   * @property {Array} speed\n   * @property {Array} sensitivity\n   * @property {number} [minX]\n   * @property {number} [maxX]\n   * @property {number} [minY]\n   * @property {number} [maxY]\n   */\n\n  // autoScroll\n  if (newOptions.autoScroll) {\n    const newAutoScrollOptions = isObject(newOptions.autoScroll)\n        ? newOptions.autoScroll\n        : {\n            target:\n              newOptions.autoScroll === true ? window : newOptions.autoScroll,\n          },\n      autoScrollOptions: any = {};\n\n    // target\n    autoScrollOptions.target = isElement(newAutoScrollOptions.target)\n      ? newAutoScrollOptions.target\n      : window;\n    // speed\n    autoScrollOptions.speed = [];\n    (Array.isArray(newAutoScrollOptions.speed)\n      ? newAutoScrollOptions.speed\n      : [newAutoScrollOptions.speed]\n    ).every((speed, i) => {\n      if (i <= 2 && isFinite(speed)) {\n        autoScrollOptions.speed[i] = speed;\n        return true;\n      }\n      return false;\n    });\n    if (!autoScrollOptions.speed.length) {\n      autoScrollOptions.speed = AUTOSCROLL_SPEED;\n    }\n    // sensitivity\n    const newSensitivity = Array.isArray(newAutoScrollOptions.sensitivity)\n      ? newAutoScrollOptions.sensitivity\n      : [newAutoScrollOptions.sensitivity];\n    autoScrollOptions.sensitivity = autoScrollOptions.speed.map((v, i) =>\n      isFinite(newSensitivity[i])\n        ? newSensitivity[i]\n        : AUTOSCROLL_SENSITIVITY[i],\n    );\n    // min*, max*\n    ['X', 'Y'].forEach(option => {\n      const optionMin = `min${option}`,\n        optionMax = `max${option}`;\n      if (\n        isFinite(newAutoScrollOptions[optionMin]) &&\n        newAutoScrollOptions[optionMin] >= 0\n      ) {\n        autoScrollOptions[optionMin] = newAutoScrollOptions[optionMin];\n      }\n      if (\n        isFinite(newAutoScrollOptions[optionMax]) &&\n        newAutoScrollOptions[optionMax] >= 0 &&\n        (!autoScrollOptions[optionMin] ||\n          newAutoScrollOptions[optionMax] >= autoScrollOptions[optionMin])\n      ) {\n        autoScrollOptions[optionMax] = newAutoScrollOptions[optionMax];\n      }\n    });\n\n    if (hasChanged(autoScrollOptions, options.autoScroll)) {\n      options.autoScroll = autoScrollOptions;\n      needsInitBBox = true;\n    }\n  } else if (newOptions.hasOwnProperty('autoScroll')) {\n    if (options.autoScroll) {\n      needsInitBBox = true;\n    }\n    options.autoScroll = void 0;\n  }\n\n  // [/AUTO-SCROLL]\n\n  if (needsInitBBox) {\n    initBBox(props);\n  }\n\n  // handle\n  if (isElement(newOptions.handle) && newOptions.handle !== options.handle) {\n    if (options.handle) {\n      // Restore\n      options.handle.style.cursor = props.orgCursor;\n      if (cssPropUserSelect) {\n        options.handle.style[cssPropUserSelect] = props.orgUserSelect;\n      }\n      pointerEvent.removeStartHandler(\n        options.handle,\n        props.pointerEventHandlerId,\n      );\n    }\n    const handle = (options.handle = newOptions.handle);\n    props.orgCursor = handle.style.cursor;\n    setDraggableCursor(handle, props.orgCursor);\n    if (cssPropUserSelect) {\n      props.orgUserSelect = handle.style[cssPropUserSelect];\n      handle.style[cssPropUserSelect] = 'none';\n    }\n    pointerEvent.addStartHandler(handle, props.pointerEventHandlerId);\n  }\n\n  // zIndex\n  if (isFinite(newOptions.zIndex) || newOptions.zIndex === false) {\n    options.zIndex = newOptions.zIndex;\n    if (props === activeProps) {\n      props.elementStyle.zIndex =\n        options.zIndex === false ? props.orgZIndex : options.zIndex;\n    }\n  }\n\n  // left/top\n  const position = { left: props.elementBBox.left, top: props.elementBBox.top };\n  let needsMove;\n  if (isFinite(newOptions.left) && newOptions.left !== position.left) {\n    position.left = newOptions.left;\n    needsMove = true;\n  }\n  if (isFinite(newOptions.top) && newOptions.top !== position.top) {\n    position.top = newOptions.top;\n    needsMove = true;\n  }\n  if (needsMove) {\n    move(props, position);\n  }\n\n  // Event listeners\n  ['onDrag', 'onMove', 'onDragStart', 'onMoveStart', 'onDragEnd'].forEach(\n    option => {\n      if (typeof newOptions[option] === 'function') {\n        options[option] = newOptions[option];\n        props[option] = options[option].bind(props.ins);\n      } else if (\n        newOptions.hasOwnProperty(option) &&\n        newOptions[option] == null\n      ) {\n        options[option] = props[option] = void 0;\n      }\n    },\n  );\n}\n\nclass PlainDraggable {\n  _id: number;\n\n  /**\n   * Create a `PlainDraggable` instance.\n   * @param {Element} element - Target element.\n   * @param {Object} [options] - Options.\n   */\n  constructor(element, options) {\n    const props: any = {\n      ins: this,\n      options: {\n        // Initial options (not default)\n        zIndex: ZINDEX, // Initial state.\n      },\n      disabled: false,\n    };\n\n    Object.defineProperty(this, '_id', { value: ++insId });\n    props._id = this._id;\n    insProps[this._id] = props;\n    props.initArguments = Array.prototype.slice.call(arguments); // [DEBUG/]\n\n    if (!isElement(element) || element === body) {\n      throw new Error('This element is not accepted.');\n    }\n    if (!options) {\n      options = {};\n    } else if (!isObject(options)) {\n      throw new Error('Invalid options.');\n    }\n\n    let gpuTrigger = true;\n    // [SVG]\n    let ownerSvg;\n    // SVGElement which is not root view\n    if (element instanceof SVGElement && (ownerSvg = element.ownerSVGElement)) {\n      // It means `instanceof SVGLocatable` (many browsers don't have SVGLocatable)\n      if (!(element as any).getBBox) {\n        throw new Error('This element is not accepted. (SVGLocatable)');\n      }\n      // Trident and Edge bug, SVGSVGElement doesn't have SVGAnimatedTransformList?\n      if (!(element as any).transform) {\n        throw new Error(\n          'This element is not accepted. (SVGAnimatedTransformList)',\n        );\n      }\n      // Trident bug, returned value must be used (That is not given value).\n      props.svgTransform = (element as any).transform.baseVal.appendItem(\n        ownerSvg.createSVGTransform(),\n      );\n      props.svgPoint = ownerSvg.createSVGPoint();\n      // Gecko bug, view.getScreenCTM returns CTM with root view.\n      const svgView = (element as any).nearestViewportElement;\n      props.svgCtmElement = !IS_GECKO\n        ? svgView\n        : svgView.appendChild(\n            document.createElementNS(ownerSvg.namespaceURI, 'rect'),\n          );\n      gpuTrigger = false;\n      props.initElm = initSvg;\n      props.moveElm = moveSvg;\n    } else {\n      // [/SVG]\n      /* eslint-disable indent */ /* [SVG/] */\n      const cssPropWillChange = CSSPrefix.getName('willChange');\n      if (cssPropWillChange) {\n        gpuTrigger = false;\n      }\n\n      if (!options.leftTop && cssPropTransform) {\n        // translate\n        if (cssPropWillChange) {\n          element.style[cssPropWillChange] = 'transform';\n        }\n        props.initElm = initTranslate;\n        props.moveElm = moveTranslate;\n      } else {\n        // left and top\n        // [LEFTTOP]\n        if (cssPropWillChange) {\n          element.style[cssPropWillChange] = 'left, top';\n        }\n        props.initElm = initLeftTop;\n        props.moveElm = moveLeftTop;\n        // [/LEFTTOP]\n        /* [LEFTTOP/]\n      throw new Error('`transform` is not supported.');\n      [LEFTTOP/] */\n      } /* [SVG/] */\n      /* eslint-enable indent */\n    } // [SVG/]\n\n    props.element = initAnim(element, gpuTrigger);\n    props.elementStyle = element.style;\n    props.orgZIndex = props.elementStyle.zIndex;\n    if (draggableClass) {\n      mClassList(element).add(draggableClass);\n    }\n    props.pointerEventHandlerId = pointerEvent.regStartHandler(pointerXY =>\n      dragStart(props, pointerXY),\n    );\n\n    // Default options\n    if (!options.containment) {\n      let parent;\n      options.containment =\n        (parent = element.parentNode) && isElement(parent) ? parent : body;\n    }\n    if (!options.handle) {\n      options.handle = element;\n    }\n\n    setOptions(props, options);\n  }\n\n  remove() {\n    const props = insProps[this._id];\n    this.disabled = true; // To restore element and reset pointer\n    pointerEvent.unregStartHandler(\n      pointerEvent.removeStartHandler(\n        props.options.handle,\n        props.pointerEventHandlerId,\n      ),\n    );\n    delete insProps[this._id];\n  }\n\n  /**\n   * @param {Object} options - New options.\n   * @returns {PlainDraggable} Current instance itself.\n   */\n  setOptions(options) {\n    if (isObject(options)) {\n      setOptions(insProps[this._id], options);\n    }\n    return this;\n  }\n\n  position() {\n    initBBox(insProps[this._id]);\n    return this;\n  }\n\n  get disabled() {\n    return insProps[this._id].disabled;\n  }\n  set disabled(value) {\n    const props = insProps[this._id];\n    if ((value = !!value) !== props.disabled) {\n      props.disabled = value;\n      if (props.disabled) {\n        if (props === activeProps) {\n          dragEnd(props);\n        }\n        props.options.handle.style.cursor = props.orgCursor;\n        if (cssPropUserSelect) {\n          props.options.handle.style[cssPropUserSelect] = props.orgUserSelect;\n        }\n        if (draggableClass) {\n          mClassList(props.element).remove(draggableClass);\n        }\n      } else {\n        setDraggableCursor(props.options.handle, props.orgCursor);\n        if (cssPropUserSelect) {\n          props.options.handle.style[cssPropUserSelect] = 'none';\n        }\n        if (draggableClass) {\n          mClassList(props.element).add(draggableClass);\n        }\n      }\n    }\n  }\n\n  get element() {\n    return insProps[this._id].element;\n  }\n\n  get rect() {\n    return copyTree(insProps[this._id].elementBBox);\n  }\n\n  get left() {\n    return insProps[this._id].elementBBox.left;\n  }\n  set left(value) {\n    setOptions(insProps[this._id], { left: value });\n  }\n\n  get top() {\n    return insProps[this._id].elementBBox.top;\n  }\n  set top(value) {\n    setOptions(insProps[this._id], { top: value });\n  }\n\n  get containment() {\n    const props = insProps[this._id];\n    return props.containmentIsBBox\n      ? ppBBox2OptionObject(props.options.containment)\n      : props.options.containment;\n  }\n  set containment(value) {\n    setOptions(insProps[this._id], { containment: value });\n  }\n\n  // [SNAP]\n  get snap() {\n    return copyTree(insProps[this._id].options.snap);\n  }\n  set snap(value) {\n    setOptions(insProps[this._id], { snap: value });\n  }\n  // [/SNAP]\n\n  // [AUTO-SCROLL]\n  get autoScroll() {\n    return copyTree(insProps[this._id].options.autoScroll);\n  }\n  set autoScroll(value) {\n    setOptions(insProps[this._id], { autoScroll: value });\n  }\n  // [/AUTO-SCROLL]\n\n  get handle() {\n    return insProps[this._id].options.handle;\n  }\n  set handle(value) {\n    setOptions(insProps[this._id], { handle: value });\n  }\n\n  get zIndex() {\n    return insProps[this._id].options.zIndex;\n  }\n  set zIndex(value) {\n    setOptions(insProps[this._id], { zIndex: value });\n  }\n\n  get onDrag() {\n    return insProps[this._id].options.onDrag;\n  }\n  set onDrag(value) {\n    setOptions(insProps[this._id], { onDrag: value });\n  }\n\n  get onMove() {\n    return insProps[this._id].options.onMove;\n  }\n  set onMove(value) {\n    setOptions(insProps[this._id], { onMove: value });\n  }\n\n  get onDragStart() {\n    return insProps[this._id].options.onDragStart;\n  }\n  set onDragStart(value) {\n    setOptions(insProps[this._id], { onDragStart: value });\n  }\n\n  get onMoveStart() {\n    return insProps[this._id].options.onMoveStart;\n  }\n  set onMoveStart(value) {\n    setOptions(insProps[this._id], { onMoveStart: value });\n  }\n\n  get onDragEnd() {\n    return insProps[this._id].options.onDragEnd;\n  }\n  set onDragEnd(value) {\n    setOptions(insProps[this._id], { onDragEnd: value });\n  }\n\n  static get draggableCursor() {\n    return cssWantedValueDraggableCursor;\n  }\n  static set draggableCursor(value) {\n    if (cssWantedValueDraggableCursor !== value) {\n      cssWantedValueDraggableCursor = value;\n      cssValueDraggableCursor = null; // Reset\n      Object.keys(insProps).forEach(id => {\n        const props = insProps[id];\n        if (\n          props.disabled ||\n          (props === activeProps && cssValueDraggingCursor !== false)\n        ) {\n          return;\n        }\n        setDraggableCursor(props.options.handle, props.orgCursor);\n        if (props === activeProps) {\n          // Since cssValueDraggingCursor is `false`, copy cursor again.\n          body.style.cursor = cssOrgValueBodyCursor;\n          body.style.cursor = window.getComputedStyle(\n            props.options.handle,\n            '',\n          ).cursor;\n        }\n      });\n    }\n  }\n\n  static get draggingCursor() {\n    return cssWantedValueDraggingCursor;\n  }\n  static set draggingCursor(value) {\n    if (cssWantedValueDraggingCursor !== value) {\n      cssWantedValueDraggingCursor = value;\n      cssValueDraggingCursor = null; // Reset\n      if (activeProps) {\n        setDraggingCursor(activeProps.options.handle);\n        if (cssValueDraggingCursor === false) {\n          setDraggableCursor(activeProps.options.handle, activeProps.orgCursor); // draggableCursor\n          body.style.cursor = cssOrgValueBodyCursor;\n        }\n        body.style.cursor =\n          cssValueDraggingCursor || // If it is `false` or `''`\n          window.getComputedStyle(activeProps.options.handle, '').cursor;\n      }\n    }\n  }\n\n  static get draggableClass() {\n    return draggableClass;\n  }\n  static set draggableClass(value) {\n    value = value ? value + '' : void 0;\n    if (value !== draggableClass) {\n      Object.keys(insProps).forEach(id => {\n        const props = insProps[id];\n        if (!props.disabled) {\n          const classList = mClassList(props.element);\n          if (draggableClass) {\n            classList.remove(draggableClass);\n          }\n          if (value) {\n            classList.add(value);\n          }\n        }\n      });\n      draggableClass = value;\n    }\n  }\n\n  static get draggingClass() {\n    return draggingClass;\n  }\n  static set draggingClass(value) {\n    value = value ? value + '' : void 0;\n    if (value !== draggingClass) {\n      if (activeProps) {\n        const classList = mClassList(activeProps.element);\n        if (draggingClass) {\n          classList.remove(draggingClass);\n        }\n        if (value) {\n          classList.add(value);\n        }\n      }\n      draggingClass = value;\n    }\n  }\n\n  static get movingClass() {\n    return movingClass;\n  }\n  static set movingClass(value) {\n    value = value ? value + '' : void 0;\n    if (value !== movingClass) {\n      if (activeProps && hasMoved) {\n        const classList = mClassList(activeProps.element);\n        if (movingClass) {\n          classList.remove(movingClass);\n        }\n        if (value) {\n          classList.add(value);\n        }\n      }\n      movingClass = value;\n    }\n  }\n}\n\npointerEvent.addMoveHandler(document, pointerXY => {\n  if (!activeProps) {\n    return;\n  }\n  const position: any = {\n    left: pointerXY.clientX + window.pageXOffset + pointerOffset.left,\n    top: pointerXY.clientY + window.pageYOffset + pointerOffset.top,\n  };\n  if (\n    move(\n      activeProps,\n      position,\n      // [SNAP]\n      activeProps.snapTargets\n        ? position => {\n            // Snap\n            const iLen = activeProps.snapTargets.length;\n            let snappedX = false,\n              snappedY = false,\n              i;\n            for (i = 0; i < iLen && (!snappedX || !snappedY); i++) {\n              const snapTarget = activeProps.snapTargets[i];\n              if (\n                (snapTarget.gravityXStart == null ||\n                  position.left >= snapTarget.gravityXStart) &&\n                (snapTarget.gravityXEnd == null ||\n                  position.left <= snapTarget.gravityXEnd) &&\n                (snapTarget.gravityYStart == null ||\n                  position.top >= snapTarget.gravityYStart) &&\n                (snapTarget.gravityYEnd == null ||\n                  position.top <= snapTarget.gravityYEnd)\n              ) {\n                if (!snappedX && snapTarget.x != null) {\n                  position.left = snapTarget.x;\n                  snappedX = true;\n                  i = -1; // Restart loop\n                }\n                if (!snappedY && snapTarget.y != null) {\n                  position.top = snapTarget.y;\n                  snappedY = true;\n                  i = -1; // Restart loop\n                }\n              }\n            }\n            position.snapped = snappedX || snappedY;\n            return activeProps.onDrag ? activeProps.onDrag(position) : true;\n          }\n        : // [/SNAP]\n          activeProps.onDrag,\n    )\n  ) {\n    // [AUTO-SCROLL]\n    const xyMoveArgs: any = {},\n      autoScroll = activeProps.autoScroll;\n    if (autoScroll) {\n      const clientXY = {\n        x: activeProps.elementBBox.left - window.pageXOffset,\n        y: activeProps.elementBBox.top - window.pageYOffset,\n      };\n\n      ['x', 'y'].forEach(axis => {\n        if (autoScroll[axis]) {\n          const min = autoScroll[axis].min,\n            max = autoScroll[axis].max;\n          autoScroll[axis].lines.some(line => {\n            if (\n              line.dir === -1\n                ? clientXY[axis] <= line.position\n                : clientXY[axis] >= line.position\n            ) {\n              xyMoveArgs[axis] = {\n                dir: line.dir,\n                speed: line.speed / 1000,\n                min,\n                max,\n              };\n              return true;\n            }\n            return false;\n          });\n        }\n      });\n    }\n    if (xyMoveArgs.x || xyMoveArgs.y) {\n      scrollFrame.move(\n        autoScroll.target,\n        xyMoveArgs,\n        autoScroll.isWindow ? scrollXYWindow : scrollXYElement,\n      );\n      position.autoScroll = true;\n    } else {\n      scrollFrame.stop();\n    }\n    // [/AUTO-SCROLL]\n\n    if (!hasMoved) {\n      hasMoved = true;\n      if (movingClass) {\n        mClassList(activeProps.element).add(movingClass);\n      }\n      if (activeProps.onMoveStart) {\n        activeProps.onMoveStart(position);\n      }\n    }\n    if (activeProps.onMove) {\n      activeProps.onMove(position);\n    }\n  }\n});\n\n{\n  function endHandler() {\n    if (activeProps) {\n      dragEnd(activeProps);\n    }\n  }\n\n  pointerEvent.addEndHandler(document, endHandler);\n  pointerEvent.addCancelHandler(document, endHandler);\n}\n\n{\n  function initDoc() {\n    cssPropTransitionProperty = CSSPrefix.getName('transitionProperty');\n    cssPropTransform = CSSPrefix.getName('transform');\n    cssOrgValueBodyCursor = body.style.cursor;\n    if ((cssPropUserSelect = CSSPrefix.getName('userSelect'))) {\n      cssOrgValueBodyUserSelect = body.style[cssPropUserSelect];\n    }\n\n    // Init active item when layout is changed, and init others later.\n\n    const LAZY_INIT_DELAY = 200;\n    let initDoneItems = {},\n      lazyInitTimer;\n\n    function checkInitBBox(props, eventType) {\n      if (props.initElm) {\n        // Easy checking for instance without errors.\n        initBBox(props, eventType);\n      } // eslint-disable-line brace-style\n      else {\n        console.log('instance may have an error:');\n        console.log(props);\n      } // [DEBUG/]\n    }\n\n    function initAll(eventType) {\n      clearTimeout(lazyInitTimer);\n      Object.keys(insProps).forEach(id => {\n        if (!initDoneItems[id]) {\n          checkInitBBox(insProps[id], eventType);\n        }\n      });\n      initDoneItems = {};\n    }\n\n    let layoutChanging = false; // Gecko bug, multiple calling by `resize`.\n    const layoutChange = AnimEvent.add(event => {\n      if (layoutChanging) {\n        return;\n      }\n      layoutChanging = true;\n\n      if (activeProps) {\n        checkInitBBox(activeProps, event.type);\n        pointerEvent.move();\n        initDoneItems[activeProps._id] = true;\n      }\n      clearTimeout(lazyInitTimer);\n      lazyInitTimer = setTimeout(() => {\n        initAll(event.type);\n      }, LAZY_INIT_DELAY);\n\n      layoutChanging = false;\n    });\n    window.addEventListener('resize', layoutChange, true);\n    window.addEventListener('scroll', layoutChange, true);\n  }\n\n  if ((body = document.body)) {\n    initDoc();\n  } else {\n    document.addEventListener(\n      'DOMContentLoaded',\n      () => {\n        body = document.body;\n        initDoc();\n      },\n      true,\n    );\n  }\n}\n\n/* [SNAP/]\nPlainDraggable.limit = true;\n[SNAP/] */\n\nexport default PlainDraggable;\n"]}